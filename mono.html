<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>KaraokeHD</title>
  <style>


 

  
 :root { --karaokeFont: system-ui, "Segoe UI", Roboto, "Noto Sans", "Helvetica Neue", Arial, sans-serif; }
  #karoCurr, #karoNext { font-family: var(--karaokeFont); }




  /* Rainbow gradient animation for 'Playing' title */
.rainbow-text{
  background: linear-gradient(
    90deg,
    #ff0066 0%,
    #ff8a00 16%,
    #ffe600 33%,
    #33cc33 50%,
    #00a3ff 66%,
    #7a00ff 83%,
    #ff0066 100%
  );
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;              /* reveal gradient through text */
  animation: rainbowShift 6s linear infinite;
  font-weight: 700;
}

@keyframes rainbowShift{
  0%   { background-position:   0% 50%; }
  50%  { background-position: 100% 50%; }
  100% { background-position:   0% 50%; }
}

/* Improve smoothness */
.rainbow-text{
  background-size: 200% 200%;
}

/* Reduced motion preference */
@media (prefers-reduced-motion: reduce){
  .rainbow-text{ animation: none; }
}

    :root{ --bg:#0f1420;--fg:#e6edf6;--muted:#9fbad1;--accent:#00b3ff;--border:#24344e;--card:#0c1625;--green:#17c964;--amber:#f5a524;--pink:#f31260;--red:#f31260; --stripW:60px; --gap:6px; --meterH:72px; --meterW:6px; --fontBase:10px; --fontTiny:9px; --radius:8px; }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
    header{padding:8px 10px;border-bottom:1px solid var(--border);background:#0c111b;position:relative;z-index:1}
    h1{margin:0;font-size:14px}
    #top{display:flex;gap:6px;flex-wrap:wrap;align-items:center;padding:8px;border-bottom:1px solid var(--border);background:#0c111b;position:sticky;top:0;z-index:1000}
    .btn{background:#122136;border:1px solid #2a3a55;color:#e6edf6;padding:7px 10px;border-radius:8px;cursor:pointer;font-size:11px}
    .btn.primary{background:var(--accent);color:#001019;border-color:#0ea5d3;font-weight:600}
    .btn.danger{background:var(--red);border-color:#aa0c43}
    .btn[disabled]{opacity:.5;cursor:not-allowed}
    label{font-size:10px;color:#a7c4de}
    select,input[type=range]{background:#122136;color:#e6edf6;border:1px solid #2a3a55;border-radius:6px}

    #vizWrap{border-bottom:1px solid var(--border);background:linear-gradient(180deg,#0b1424,#0a1220);} #mainViz{display:block;width:100%;height:84px}

    .floatWin{position:fixed;top:120px;left:16px;min-width:260px;min-height:120px;background:#0b1424;border:1px solid #20324d;border-radius:12px;box-shadow:0 10px 32px rgba(0,0,0,.45);display:none;z-index:10000;height:72vh;overflow:auto}
    .winHeader{display:flex;align-items:center;justify-content:space-between;padding:6px 8px;border-bottom:1px solid #1f2c44;background:#0c111b;border-top-left-radius:12px;border-top-right-radius:12px;cursor:move;position:sticky;top:0;z-index:2}
    .winHeader strong{font-size:12px}
    .winBtns{display:flex;gap:6px}
    .winBody{padding:8px}

    #chGridVert{display:grid;grid-auto-flow:column;grid-auto-columns:var(--stripW);gap:var(--gap);overflow:auto;align-items:start}
    .strip{background:#0b1424;border:1px solid #20324d;border-radius:var(--radius);padding:4px;display:flex;flex-direction:column;align-items:center}
    .strip .title{display:flex;align-items:center;justify-content:center;margin-bottom:2px;font-size:var(--fontBase)}
    .badge{background:#16263f;border:1px solid #2a3a55;color:#a7c4de;padding:0 4px;border-radius:999px;font-size:var(--fontTiny);margin-left:4px}
    .vMeter{height:var(--meterH);width:var(--meterW);border:1px solid #2a3a55;border-radius:999px;background:#122136;margin:4px 0;position:relative;overflow:hidden}
    .vMeter .bar{position:absolute;bottom:0;left:0;right:0;background:linear-gradient(180deg,#17c964,#f5a524,var(--pink));height:0%;width:100%}
    .controls{display:flex;flex-direction:column;gap:4px;font-size:var(--fontTiny);align-items:center;width:100%}
    .row{display:flex;gap:4px;align-items:center}
    .chip{display:inline-flex;align-items:center;gap:4px;border:1px solid #2a3a55;background:#10182a;color:#a7c4de;border-radius:999px;padding:2px 6px;font-size:9px}
    .ctlV{display:flex;flex-direction:column;gap:3px;align-items:center}
    .symSel{width:100%;font-size:10px}

    .plItem{padding:5px;border-bottom:1px solid #22324b;cursor:pointer;font-size:11px}
    .plItem.active{background:#122136}
    pre.log{white-space:pre-wrap;margin:0;color:#b6c9dc;font-size:11px}

    .density-ultra{--stripW:60px; --meterH:72px; --meterW:6px; --gap:6px; --fontBase:10px; --fontTiny:9px; --radius:8px}
    .density-compact{--stripW:72px; --meterH:84px; --meterW:7px; --gap:7px; --fontBase:11px; --fontTiny:10px}
    .density-normal{--stripW:96px; --meterH:108px; --meterW:8px; --gap:8px; --fontBase:12px; --fontTiny:11px}

    .lyTok { display:inline-block; margin:0 .06em; }
    .lyTok.done { opacity:0.92; }
    .lyTok.active { color:var(--accent); }

    /* === Audio-only mode UI reductions (ADD) === */
    body.audio-only #vizWrap { display:none !important; }
    body.audio-only .floatWin { display:none !important; }
    body.audio-only #top [aria-label="Mixer"],
    body.audio-only #top [aria-label="EQ"],
    body.audio-only #top [aria-label="Playlist"],
    body.audio-only #top [aria-label="Log"],
    body.audio-only #top [aria-label="Lyrics"],
    body.audio-only #top [aria-label="Karaoke"],
    body.audio-only #top [aria-label="Karaoke Settings"] {
      display:none !important;
    }
    body.audio-only #top { gap: 8px; }

    #winKaro{ --kara-fill: var(--accent); --kara-base:#ffffff; --kara-bg: rgba(0,0,0,0); --kara-weight:800; --kara-letter-spacing:0em; --kara-token-gap:0.04em; --glow-radius:10px; --glow-radius2:14px; --kara-blend:normal; --kara-stroke-w:1px; --kara-stroke-c: rgba(0,0,0,0.55); background: var(--kara-bg) !important; border-color: transparent; }
    #winKaro .winHeader{ background: var(--kara-bg) !important; border-bottom-color: transparent; }
    #winKaro .winBody{ background: var(--kara-bg); font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    #karoCurr{ font-size: clamp(18px, 5.2vw, 34px); line-height: 1.30; font-weight: var(--kara-weight); margin: 8px 0; white-space: pre-wrap; }
    /* Next line: fully visible for chroma; size driven by --next-size set via JS */

#karoNext{
  font-size: var(--next-size, clamp(14px, 3.2vw, 20px));
  /* push it a bit further down (adjust these px values to taste) */
  margin: 14px 0 6px;

  white-space: pre-wrap;
  opacity: 1 !important;                 /* ensure not muted */
  color: var(--kara-base) !important;     /* base lyric color */

  /* remove filter lines and add a subtle outline for readability */
  text-shadow: none !important;
  filter: none !important;
  /* REPLACED: -webkit-filter: none !important; */
  -webkit-text-stroke: 1px rgba(0,0,0,0.55) !important;
  text-stroke: 0.5px rgba(0,0,0,0.55) !important;

  mix-blend-mode: normal !important;
}

    #winKaro.karo-align-left  #karoCurr, #winKaro.karo-align-left  #karoNext{ text-align:left; }
    #winKaro.karo-align-center #karoCurr, #winKaro.karo-align-center #karoNext{ text-align:center; }
    .karoToken{ display:inline-block; margin:0 var(--kara-token-gap); }
    .karoChar{ position:relative; display:inline-block; letter-spacing:var(--kara-letter-spacing); }
    .karoLetter.base{ position:relative; color: var(--kara-base); text-shadow: 1px 2px 6px rgba(10,30,55,0.60); }
    .karoLetter.hi{ position:absolute; left:0; top:0; color: var(--kara-fill); text-shadow: 0 0 var(--glow-radius) var(--kara-fill), 0 0 var(--glow-radius2) var(--kara-fill); clip-path: inset(0 calc(100% - var(--kara-progress, 0%)) 0 0); mix-blend-mode: var(--kara-blend); }
    #winKaro.karo-micro-stroke .karoLetter.base, #winKaro.karo-micro-stroke .karoLetter.hi{ -webkit-text-stroke: var(--kara-stroke-w) var(--kara-stroke-c); text-stroke: var(--kara-stroke-w) var(--kara-stroke-c); }
    #winKaro.karo-chroma-safe{ --glow-radius: 0px; --glow-radius2: 0px; --kara-blend: normal; --kara-fill: #ffd84a; }
    #winKaro.karo-chroma-safe .karoLetter.base, #winKaro.karo-chroma-safe .karoLetter.hi{ text-shadow:none !important; filter:none !important; -webkit-filter:none !important; mix-blend-mode: normal !important; }

    #winKaro:fullscreen, #winKaro:-webkit-full-screen { background: var(--kara-bg) !important; width: 100vw !important; height: 100vh !important; top:0 !important; left:0 !important; border-radius:0 !important; }

    @media (max-width: 720px) { .floatWin { left:8px !important; right:8px !important; width: calc(100vw - 16px) !important; height: 72vh; } #winChannels { width: calc(100vw - 16px) !important; } #winKaro { width: calc(100vw - 16px) !important; } .btn { padding: 10px 12px; font-size: 12px; } select, input[type=range] { font-size: 12px; } }
    @media (min-width: 1280px) { #mainViz { height: 120px; } }
    @media (pointer: coarse) { .btn { padding: 10px 12px; font-size: 12px; } select, input[type=range] { font-size: 12px; } }
    .plItem { display:flex; align-items:center; justify-content:space-between; gap:6px; }
.plItem .btn { padding:4px 8px; font-size:10px; }



/* Provide a fixed top spacer in the Karaoke window body
   so content starts BELOW the absolute-positioned chips */
#winKaro .winBody {
  padding-top: 30px !important;   /* adjust to taste: 20‚Äì32px */
}

/* Optional: small additional nudges for the two lines */
#karoCurr {
  margin-top: 12px !important;    /* keep modest; padding does the main work */
  /* original was 8px 0 */
}

#karoNext {
  margin-top: 10px !important;    /* original top was 6px */
  /* original full: margin: 6px 0 4px; */
}


/* Tiny color dots for Solf/Retune ‚Äî no text */
#solfDetect, #tuneDetect{
  display: inline-block;
  width: 10px;            /* dot size */
  height: 10px;
  border-radius: 999px;   /* circle */
  border: 1px solid #2a3a55;
  padding: 0;
  font-size: 0;           /* hide any text */
  line-height: 0;
}


/* === Chroma-safe styling for BIG start countdown === */
/* Big number: flat, high-contrast color; no glow; no blend */
#karoStartBigDynamic {
  color: #ffd84a !important;          /* solid golden-yellow (good on dark BG) */
  text-shadow: none !important;       /* remove glow */
  filter: none !important;
  -webkit-filter: none !important;
  mix-blend-mode: normal !important;
  -webkit-text-stroke: 1px rgba(0,0,0,0.55); /* subtle edge for legibility */
}

/* Bars: same solid color; no glow */
#karoStartBarsDynamic .karoStartSegDynamic {
  background: #ffd84a !important;     /* match the big number color */
  box-shadow: none !important;        /* remove glow */
}

/* Add an outside stroke to the countdown bars */
#karoStartBarsDynamic .karoStartSegDynamic{
  outline: 1px solid rgba(0,0,0,0.55) !important;  /* subtle edge outside */
  outline-offset: 0;                                /* sit flush to the edge */
  box-shadow: none !important;                      /* keep chroma-safe */
}

  </style>
</head>
<body class="density-ultra">
    
<header style="text-align:left; padding:8px 10px;">
  <h1 style="margin:0; font-size:30px; line-height:1.2;">
    <strong style="
      color:#f31260;
      font-weight:900;
      font-size:40px;
      text-shadow: 0 0 12px rgba(243,18,96,0.8), 0 0 24px rgba(243,18,96,0.6);
    ">
      KaraokeHD
    </strong>
    <span style="color:#9fbad1; font-size:20px;"> ‚Äî </span>
    <strong style="color:#39FF14; font-weight:900;">codex45</strong>
    <span style="color:#9fbad1; font-size:18px;"> (v5.4b.1‚Äëperf)</span>
  </h1>

  <small id="hdrTagline" style="display:block; margin-top:6px; color:#9fbad1; font-size:10px;">
    Ultra‚ÄëCompact Mixer ‚Ä¢ Visualizer ‚Ä¢ Recording ‚Ä¢ Retune ‚Ä¢ Lyrics ‚Ä¢ Karaoke
  </small>

  <div id="nowPlaying" style="margin-top:10px; font-size:18px; font-weight:700;">
    <span style="color:#9fbad1;">Playing:</span>
    <span id="currentTitle" class="rainbow-text">(No track loaded)</span>
  </div>
</header>

  <div id="vizWrap"><canvas id="mainViz" aria-label="Wave Visualizer"></canvas></div>

  <div id="top">
    <input id="midFiles" type="file" multiple accept=".mid,.kar"/>
    <button id="btnInit" class="btn primary">Init</button>
    <button id="btnPlay" class="btn" disabled aria-label="Play">‚ñ∂</button>
    <button id="btnStop" class="btn" disabled aria-label="Stop">‚èπ</button>
    <button id="btnPanic" class="btn danger" disabled aria-label="Panic">‚õë</button>

    <label>Assign
      <select id="autoAssign"><option value="1" selected>On</option><option value="0">Off</option></select>
    </label>
    <label>Recovery
      <select id="autoRecovery"><option value="1" selected>On</option><option value="0">Off</option></select>
    </label>
    <label>Palette
      <select id="palette"><option value="classic" selected>Classic</option><option value="edm">EDM</option><option value="chip">Chip</option></select>
    </label>
    <label>Preset
      <select id="preset"><option value="Flat" selected>Flat</option><option value="Warm">Warm</option><option value="Bright">Bright</option><option value="Vocal">Vocal</option><option value="BassBoost">Bass+</option><option value="BassStrong">Bass++</option></select>
    </label>
    <label>Soft Synth <input id="softSynth" type="checkbox"/></label>
    <label>Anti‚ÄëBeep <input id="antiBeep" type="checkbox" checked/></label>
    <label>Lim <input id="limStr" type="range" min="0.50" max="0.95" value="0.78" step="0.01"/></label>
    <label>Notch <select id="notch"><option value="0">Off</option><option value="50">50</option><option value="60" selected>60</option></select></label>

    <label>Density
      <select id="density"><option value="ultra" selected>Ultra</option><option value="compact">Compact</option><option value="normal">Normal</option></select>
    </label>
    <label>Fit‚Äë16 <input id="fit16" type="checkbox" checked/></label>

    <!-- ADD: Audio-only toggle -->
    <label>Audio‚Äëonly <input id="audioOnly" type="checkbox"/></label>

    <span style="display:flex;gap:6px;margin-left:8px">
      <button id="btnRecNow" class="btn">‚è∫ Rec Now</button>
      <button id="btnRecRestart" class="btn">‚è∫ Rec Restart</button>
      <button id="btnRecStop" class="btn" disabled>‚èπ Stop Rec</button>
      <a id="recDownload" class="btn" style="display:none" download>‚¨áÔ∏è Save</a>
    </span>

    <span style="display:flex;gap:6px;margin-left:8px;flex-wrap:wrap">
      <label>Solfeggio <input id="solfEnable" type="checkbox"/></label>
      <label>Type <select id="solfType"><option value="binaural" selected>Binaural</option><option value="mono">Mono</option></select></label>
      
<label>Freq
  <select id="solfFreq">
    <option value="174">174 Hz ‚Äì Foundation</option>
    <option value="285">285 Hz ‚Äì Healing</option>
    <option value="396">396 Hz ‚Äì Liberation</option>
    <option value="417">417 Hz ‚Äì Change</option>
    <option value="528" selected>528 Hz ‚Äì Transformation</option>
    <option value="639">639 Hz ‚Äì Connection</option>
    <option value="741">741 Hz ‚Äì Awakening</option>
    <option value="852">852 Hz ‚Äì Intuition</option>
    <option value="963">963 Hz ‚Äì Divine</option>
  </select>
</label>
      <label>Level <input id="solfLevel"type="range" min="0" max="0.40" step="0.01" value="0.12"/></label>
      <span id="solfDetect" class="chip" style="margin-left:8px" title="Goertzel power at target">
  Solf detect: --
</span>


      <label style="margin-left:12px">Retune Mix <input id="tuneEnable" type="checkbox"/></label>
<label>Target
  <select id="tuneFreq">
    <option value="174">174 Hz ‚Äì Foundation</option>
    <option value="285">285 Hz ‚Äì Healing</option>
    <option value="396">396 Hz ‚Äì Liberation</option>
    <option value="417">417 Hz ‚Äì Change</option>
    <option value="528" selected>528 Hz ‚Äì Transformation</option>
    <option value="639">639 Hz ‚Äì Connection</option>
    <option value="741">741 Hz ‚Äì Awakening</option>
    <option value="852">852 Hz ‚Äì Intuition</option>
    <option value="963">963 Hz ‚Äì Divine</option>
  </select>
</label>
      
    </span>
<span id="tuneDetect" class="chip" style="margin-left:8px" title="Goertzel power at retune target">
  Retune detect: --
</span>

    <span style="display:flex;gap:6px;margin-left:8px">
      <label>Continuous
        <select id="contMode">
          <option value="off" selected>Off</option>
          <option value="next">Play Next</option>
          <option value="loop">Loop Current</option>
        </select>
      </label>
    </span>

    <span style="margin-left:auto;display:flex;gap:6px">
      <button class="btn" onclick="toggleWin('winChannels')" aria-label="Mixer">üéö</button>
      <button class="btn" onclick="toggleWin('winEQ')" aria-label="EQ">üéõ</button>
      <button class="btn" onclick="toggleWin('winPlaylist')" aria-label="Playlist">üìú</button>
      <button class="btn" onclick="toggleWin('winLog')" aria-label="Log">üßæ</button>
      <button class="btn" onclick="toggleWin('winLyrics')" aria-label="Lyrics">üìñ</button>
      <button class="btn" onclick="toggleWin('winKaro')" aria-label="Karaoke">üé§</button>
      <button class="btn" onclick="toggleWin('winKaroSettings')" aria-label="Karaoke Settings">‚öôÔ∏èüé§</button>

   <button id="karoResetPos" class="btn" type="button" title="Karaoke window">
    ‚§¢üé§
   </button>

      <!-- NEW: whole-page fullscreen -->
      <button id="btnPageFS" class="btn" aria-label="Full Screen" title="Full screen">‚õ∂</button>
    </span>
  </div>

  <div id="winChannels" class="floatWin" style="width:98vw;left:8px;" role="dialog" aria-modal="false" aria-labelledby="winChannelsTitle">
    <div class="winHeader"><strong id="winChannelsTitle">üéö Mixer</strong><span class="winBtns"><button class="btn" onclick="toggleWin('winChannels')">‚úï</button></span></div>
    <div class="winBody">
      <div id="chToolbar" class="row" style="margin-bottom:6px;justify-content:space-between">
        <span class="chip" id="usedSummary">Used 0/16</span>
        <span class="chip" id="activeSummary">Now 0</span>
        <button id="btnResetUsed" class="btn">‚Ü∫</button>
      </div>
      <div id="chGridVert" aria-label="Channel Mixer"></div>
    </div>
  </div>

  <div id="winEQ" class="floatWin" style="width:320px;" role="dialog" aria-modal="false" aria-labelledby="winEQTitle">
    <div class="winHeader"><strong id="winEQTitle">üéõ EQ</strong><span class="winBtns"><button class="btn" onclick="toggleWin('winEQ')">‚úï</button></span></div>
    <div class="winBody">
      <div class="row" style="flex-direction:column;gap:6px;font-size:10px">
        <label>31 <input id="eq10_0" type="range" min="-12" max="12" value="0" step="1" aria-label="31 Hz"/></label>
        <label>62 <input id="eq10_1" type="range" min="-12" max="12" value="0" step="1" aria-label="62 Hz"/></label>
        <label>125<input id="eq10_2" type="range" min="-12" max="12" value="0" step="1" aria-label="125 Hz"/></label>
        <label>250<input id="eq10_3" type="range" min="-12" max="12" value="0" step="1" aria-label="250 Hz"/></label>
        <label>500<input id="eq10_4" type="range" min="-12" max="12" value="0" step="1" aria-label="500 Hz"/></label>
        <label>1k<input id="eq10_5" type="range" min="-12" max="12" value="0" step="1" aria-label="1 kHz"/></label>
        <label>2k<input id="eq10_6" type="range" min="-12" max="12" value="0" step="1" aria-label="2 kHz"/></label>
        <label>4k<input id="eq10_7" type="range" min="-12" max="12" value="0" step="1" aria-label="4 kHz"/></label>
        <label>8k<input id="eq10_8" type="range" min="-12" max="12" value="0" step="1" aria-label="8 kHz"/></label>
        <label>16k<input id="eq10_9" type="range" min="-12" max="12" value="0" step="1" aria-label="16 kHz"/></label>
        <button id="btnCalm" class="btn">üß∞ Calm</button>
      </div>
    </div>
  </div>

  <div id="winPlaylist" class="floatWin" style="width:320px;" role="dialog" aria-modal="false" aria-labelledby="winPlaylistTitle">
    <div class="winHeader"><strong id="winPlaylistTitle">üìú List</strong><span class="winBtns"><button class="btn" onclick="toggleWin('winPlaylist')">‚úï</button></span></div>
    <div class="winBody"><div id="plList"></div></div>
  </div>

  <div id="winLog" class="floatWin" style="width:320px;" role="dialog" aria-modal="false" aria-labelledby="winLogTitle">
    <div class="winHeader"><strong id="winLogTitle">üßæ Log</strong><span class="winBtns"><button class="btn" onclick="toggleWin('winLog')">‚úï</button></span></div>
    <div class="winBody"><pre id="status" class="log" role="status" aria-live="polite">Ready (v5.4b.1‚Äëperf). Mixer DOM built once; per‚Äëframe updates are meter bars + counters only. Mobile/desktop responsive tweaks applied. Recording + Solfeggio overlay + Master Retune + Continuous Play + Lyrics + Karaoke. Global error logging enabled. Settings persisted to localStorage. Karaoke window frame/header/body follow Karaoke BG (no bands). Bugfixes applied.</pre></div>
  </div>

  <div id="winLyrics" class="floatWin" style="width:460px;" role="dialog" aria-modal="false" aria-labelledby="winLyricsTitle">
    <div class="winHeader">
      <strong id="winLyricsTitle">üìñ Lyrics</strong>
      <span class="winBtns"><button class="btn" onclick="toggleWin('winLyrics')">‚úï</button></span>
    </div>
    <div class="winBody" style="font-size:11px">
      <div style="display:flex; gap:6px; flex-wrap:wrap; align-items:center; margin-bottom:8px">
        <label>Source
          <select id="lySrc">
            <option value="05" selected>0x05 only</option>
            <option value="05+01">0x05 + 0x01</option>
            <option value="05+01+03">0x05 + 0x01 + 0x03</option>
          </select>
        </label>
        <label><input type="checkbox" id="lyPreserve" checked> Preserve spaces</label>
        <label><input type="checkbox" id="lySplitSlash" checked> Split on ‚Äú/‚Äù</label>
        <label>Encoding
          <select id="lyEnc">
            <option value="latin1" selected>Latin‚Äë1</option>
            <option value="utf8">UTF‚Äë8</option>
          </select>
        </label>
        <button class="btn" id="btnLyFull">Full</button>
        <button class="btn" id="btnLyTokens">Tokens</button>
      </div>

      <div id="lyPrev" style="color:#9fbad1; margin:4px 0 2px"></div>
      <div id="lyCurr" style="font-weight:700; margin:2px 0 2px"></div>
      <div id="lyNext" style="color:#b6c9dc; margin:2px 0 6px"></div>

      <div id="lyFull" style="display:none;"></div>
      <div id="lyTokens" style="display:none;"></div>
    </div>
  </div>

  <div id="winKaro" class="floatWin" style="width:680px;" role="dialog" aria-modal="false" aria-labelledby="winKaroTitle">
    <div class="winHeader">
      <strong id="winKaroTitle">karaokeHD</strong>
      <span class="winBtns">
        <button class="btn" id="btnKaroFS" title="Fullscreen" aria-pressed="false">‚õ∂</button>
        <button class="btn" onclick="toggleWin('winKaro')">‚úï</button>
      </span>
    </div>
    <div class="winBody" style="font-size:11px">
      <div id="karoCurr"></div>
      <div id="karoNext"></div>
    </div>
  </div>

  <div id="winKaroSettings" class="floatWin" style="width:520px;" role="dialog" aria-modal="false" aria-labelledby="winKaroSettingsTitle">
    <div class="winHeader">
      <strong id="winKaroSettingsTitle">‚öôÔ∏è Karaoke Settings</strong>
      <span class="winBtns"><button class="btn" onclick="toggleWin('winKaroSettings')">‚úï</button></span>
    </div>
    <div class="winBody" style="font-size:11px">
      <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin-bottom:8px">
        <label>Align <select id="karoAlign"><option value="left">Left</option><option value="center" selected>Center</option></select></label>
        <label><input type="checkbox" id="karoLettersOnly"> Letters‚Äëonly</label>
        <label><input type="checkbox" id="karoChromaSafe" checked> Chroma‚Äësafe</label>
        <label><input type="checkbox" id="karoMicroStroke" checked> Micro‚Äëstroke</label>
        <label><input type="checkbox" id="karoAOD"> AOD (prevent sleep)</label>
        <label>Fill <input type="color" id="karoFill" value="#00b3ff"></label>
        <label>Base <input type="color" id="karoBase" value="#ffffff"></label>
        <label>BG   <input type="color" id="karoBg"   value="#000000"></label>
        <label>Glow <input type="range" id="karoGlow" min="0" max="24" step="1" value="10"></label>
        <label>Stroke <input type="range" id="karoStrokeW" min="0" max="6" step="0.5" value="1"></label>
        <label>Blend <select id="karoBlend"><option value="normal" selected>Normal</option><option value="screen">Screen</option><option value="overlay">Overlay</option><option value="lighten">Lighten</option><option value="multiply">Multiply</option></select></label>
        <label>Weight <input type="range" id="karoWeight" min="300" max="900" step="50" value="800"></label>
        <label>Letter‚Äëspacing (em) <input type="range" id="karoLS" min="-0.02" max="0.20" step="0.01" value="0"></label>
        <label>Token gap (em) <input type="range" id="karoGap" min="0" max="0.30" step="0.01" value="0.04"></label>
        <label>Case <select id="karoCase"><option value="none" selected>As is</option><option value="upper">ALL CAPS</option><option value="lower">all small</option><option value="cap">Cap Each Word</option><option value="sentence">Sentence</option></select></label>
      </div>
    </div>


<!-- ‚öôÔ∏è Karaoke Settings ‚Ä∫ Font -->

<div class="ks-row" id="ks-font-upload-row">
  <input id="ks-font-file" type="file" accept=".ttf,.otf,.woff,.woff2" />
  <button id="ks-font-use-upload" class="ks-btn">Use uploaded (no server)</button>
  <button id="ks-font-save-idb" class="ks-btn">Save locally (IndexedDB)</button>
</div>

<label class="ks-label">Lyrics font</label>
<select id="ks-font-family" class="ks-input"></select>
<small class="ks-note">Applies to <b>#karoCurr</b> and <b>#karoNext</b>.</small>

<div class="ks-row">
  <button id="ks-scan-device-fonts" class="ks-btn">List device fonts (if supported)</button>
  <span id="ks-device-fonts-status" class="ks-note"></span>
</div>

<div class="ks-row">
  <input id="ks-font-manual-name" class="ks-input" placeholder="Type a device font name‚Ä¶ e.g., 'Calibri'"/>
  <button id="ks-test-manual-font" class="ks-btn">Test & apply</button>
</div>
  </div>




  <script>
  const MUTE_FACTOR = 0.30; const STORAGE_KEY = 'MIDI_POC_Ultra_v5.4b.1';
  const log = (msg)=>{ const el=document.getElementById('status'); el.textContent += `\n${msg}`; el.scrollTop = el.scrollHeight; };
  window.addEventListener('error', (e)=>{ try{ log('JS Error: ' + (e.message || e)); }catch(_){} });

  let zCounter = 10000;
  function toggleWin(id){ const w=document.getElementById(id); if(!w) return; const show = (w.style.display==='none' || w.style.display===''); w.style.display = show? 'block':'none'; if(show){ w.style.zIndex = (++zCounter).toString(); } settings.windows = settings.windows || {}; settings.windows[id] = settings.windows[id] || {}; settings.windows[id].display = w.style.display; persistSettings(); }
  (function(){ const wins=['winChannels','winEQ','winPlaylist','winLog','winLyrics','winKaro','winKaroSettings']; for(const id of wins){ const w=document.getElementById(id); const hdr=w.querySelector('.winHeader'); let ox=0, oy=0, dragging=false; const start=(x,y)=>{ dragging=true; ox=x - w.offsetLeft; oy=y - w.offsetTop; document.body.style.userSelect='none'; w.style.zIndex=(++zCounter).toString(); }; const move=(x,y)=>{ if(!dragging) return; w.style.left=(x-ox)+'px'; w.style.top=(y-oy)+'px'; }; const end=()=>{ dragging=false; document.body.style.userSelect='auto'; settings.windows = settings.windows || {}; settings.windows[id] = settings.windows[id] || {}; settings.windows[id].left = w.style.left; settings.windows[id].top = w.style.top; settings.windows[id].width = w.style.width; persistSettings(); }; hdr.addEventListener('mousedown',(e)=>start(e.clientX,e.clientY)); document.addEventListener('mousemove',(e)=>move(e.clientX,e.clientY)); document.addEventListener('mouseup',end); hdr.addEventListener('touchstart',(e)=>{ const t=e.touches[0]; start(t.clientX,t.clientY); },{passive:true}); document.addEventListener('touchmove',(e)=>{ const t=e.touches[0]; move(t.clientX,t.clientY); },{passive:true}); document.addEventListener('touchend',end); } })();

  const INST_SYM = { pianoLite:'üéπ', deepBass:'üß±', guitar:'üé∏', drumLite:'ü•Å', triangle:'‚ñ≥', square:'‚ñ¢', saw:'‚ö°', fm:'‚àø' };
  function instSymbol(name){ return INST_SYM[name] || '‚ó¶'; }
  function chanFallbackInst(ch){ if(ch===9) return 'drumLite'; if(ch===0) return 'pianoLite'; if(ch===1||ch===3) return 'deepBass'; if(ch===5||ch===6) return 'triangle'; if(ch>=10 && ch<=15) return 'square'; return 'saw'; }

  let audioCtx=null; let masterIn=null; let masterOut=null; let transport=null; let hpf=null; let notch=null; let clip=null; let analyser=null;
  let mediaDest=null; let mediaRecorder=null; let recChunks=[];
  const EQ_FREQS=[31,62,125,250,500,1000,2000,4000,8000,16000]; let eqBands=[];
  let useTriangle=false; let antiBeep=true; let autoRecovery=true; let autoAssign=true; let palette='classic';
  const MIN_NOTE_MS_MELODY=140, MIN_NOTE_MS_DRUMS=110, GAP_SEC=0.150; const ENV_ATTACK=0.010, ENV_RELEASE=0.090;
  
  let vizCanvas=null, vizCtx=null, vizBuffer=null, vizBufferF=null;
  
  let solfEnable=false, solfType='binaural', solfFreq=528.0; const BEAT_DELTA_HZ=4.0; let solfGainNode=null, solfOscL=null, solfOscR=null, solfPanL=null, solfPanR=null;
  let tuneEnable=false, tuneFreq=528.0, globalDetuneRatio=1.0; let contMode='off';

  const channels = Array(16).fill(null).map((_,i)=>({ gain:null, pan:null, baseGain:(i===9?1.0:0.70), expr:1.0, sustain:false, bend:0, inst: chanFallbackInst(i), lastNote:null, locked:false, prog:null, mute:false, solo:false }));
  const chAct = Array(16).fill(null).map(()=>({ level:0, last:0 })); const chSeen = Array(16).fill(false);
  const voices=[]; const seq={ events:[], startTime:0, startTick:0, ptr:0, running:false, lookAhead:0.03, scheduleAhead:0.20, timer:null }; const playlist=[]; let currentIndex=-1; let _tempo=null;
  const FAILSAFE_TABLE={ drumLite:{lvl:0.40,idle:1.8}, deepBass:{lvl:0.35,idle:1.6}, pianoLite:{lvl:0.32,idle:1.6}, guitar:{lvl:0.30,idle:1.8}, triangle:{lvl:0.28,idle:2.0}, square:{lvl:0.28,idle:2.0}, saw:{lvl:0.28,idle:2.0}, fm:{lvl:0.30,idle:1.8} };

  const defaults = { lyrics:{ source:'05', preserveSpaces:true, splitOnSlash:true, enc:'latin1' }, karaoke:{ align:'center', lettersOnly:false, chromaSafe:true, microStroke:true, aod:false, fill:'#00b3ff', base:'#ffffff', bg:'rgba(0,0,0,0)', glow:10, strokeW:1, blend:'normal', weight:800, letterSpacing:0, tokenGap:0.04, case:'none' }, ui:{ density:'ultra', fit16:true, palette:'classic', preset:'Flat', contMode:'off', autoAssign:true, autoRecovery:true, audioOnly:false }, audio:{ limiter:0.78, notch:60, solfEnable:false, solfType:'binaural', solfFreq:528, solfLevel:0.12, tuneEnable:false, tuneFreq:528 }, windows:{} };
  let settings = loadSettings(); function loadSettings(){ try{ const s=JSON.parse(localStorage.getItem(STORAGE_KEY)||'{}'); return deepMerge(JSON.parse(JSON.stringify(defaults)), s||{}); }catch(e){ return JSON.parse(JSON.stringify(defaults)); } }
  function persistSettings(){ try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(settings)); }catch(e){} }
  function deepMerge(a,b){ for(const k of Object.keys(b)){ if(b[k]&&typeof b[k]==='object'&&!Array.isArray(b[k])){ if(!a[k]||typeof a[k]!=='object'){ a[k]={}; } a[k]=deepMerge(a[k],b[k]); } else { a[k]=b[k]; } } return a; }

  const lyrics = { source:settings.lyrics.source, preserveSpaces:settings.lyrics.preserveSpaces, splitOnSlash:settings.lyrics.splitOnSlash, enc:settings.lyrics.enc, json:{lines:[]}, startAt:0, raf:0 };
  const KaroState = { linesPrepared:[], lettersOnly:settings.karaoke.lettersOnly, raf:0, startAt:0, align:settings.karaoke.align, case:settings.karaoke.case };

  let mixerBuilt=false; const meterBars=new Array(16); const titleBadges=new Array(16);

  // === Audio-only helpers (ADD) ===
  let audioOnly = false;          // runtime flag mirrors settings.ui.audioOnly
  let drawVizEnabled = true;      // gate for visualizer loop
  let goertzelEnabled = true;     // gate for detectors loop
  // Track RAF IDs so we can cancel safely when toggling
  let _vizRAF = 0;
  let _goertzelRAF = 0;
  // ADD: track analyser bypass wiring
  let analyserBypassed = false;

  // ADD: rewire final stage with or without analyser
  function wireFinalStage(useAnalyser){
    if (!clip || !transport) return;
    try {
      // Disconnect previous routing
      try{ clip.disconnect(); }catch(_){}
      if (useAnalyser && analyser){
        // clip ‚Üí analyser ‚Üí transport
        clip.connect(analyser);
        try{ analyser.disconnect(); }catch(_){}
        analyser.connect(transport);
      } else {
        // clip ‚Üí transport (bypass analyser)
        clip.connect(transport);
      }
      // Ensure transport goes to destination and media stream (single point)
      try{ transport.disconnect(); }catch(_){}
      transport.connect(masterOut);
      transport.connect(mediaDest);
    } catch(e) {
      try{ log('Wire error: '+(e.message||e)); }catch(_){}
    }
  }

  function applyAudioOnlyUI(on){
    audioOnly = !!on;
    document.body.classList.toggle('audio-only', audioOnly);

    if (audioOnly){
      drawVizEnabled = false;
      goertzelEnabled = false;
      try { if (_vizRAF) cancelAnimationFrame(_vizRAF); } catch(_) {}
      try { if (_goertzelRAF) cancelAnimationFrame(_goertzelRAF); } catch(_) {}
      try { LyricsLive.stop(); } catch(_) {}
      try { Karo.stop(); } catch(_) {}
    } else {
      drawVizEnabled = true;
      goertzelEnabled = true;
      try { _vizRAF = requestAnimationFrame(drawWave); } catch(_) {}
      try { _goertzelRAF = requestAnimationFrame(goertzelDetectLoop); } catch(_) {}
    }
  }

  function buildMixerOnce(){ if(mixerBuilt) return; const grid=document.getElementById('chGridVert'); grid.innerHTML=''; for(let ch=0; ch<16; ch++){ const st=channels[ch]; const act=chAct[ch]; const strip=document.createElement('div'); strip.className='strip'; strip.dataset.ch=ch; strip.title=(ch+1)+' '+(st.inst||'')+(st.locked?' üîí':''); const ttl=document.createElement('div'); ttl.className='title'; const name=document.createElement('strong'); name.textContent=String(ch+1); ttl.appendChild(name); const badge=document.createElement('span'); badge.className='badge'; badge.textContent=instSymbol(st.inst||'triangle'); ttl.appendChild(badge); titleBadges[ch]=badge; strip.appendChild(ttl); const meter=document.createElement('div'); meter.className='vMeter'; const bar=document.createElement('div'); bar.className='bar'; bar.style.height=Math.min(100, Math.floor((act.level||0)*100))+'%'; meter.appendChild(bar); strip.appendChild(meter); meterBars[ch]=bar; const controls=document.createElement('div'); controls.className='controls'; const ctl=document.createElement('div'); ctl.className='ctlV'; const sel=document.createElement('select'); sel.className='symSel'; sel.innerHTML='<option value="triangle">‚ñ≥</option>'+'<option value="saw">‚ö°</option>'+'<option value="square">‚ñ¢</option>'+'<option value="guitar">üé∏</option>'+'<option value="deepBass">üß±</option>'+(ch===9?'<option value="drumLite" selected>ü•Å</option>':'<option value="pianoLite">üéπ</option>'); sel.value=(st.inst||'triangle'); sel.addEventListener('change',(e)=>{ st.inst=e.target.value; st.locked=true; titleBadges[ch].textContent=instSymbol(st.inst); strip.title=(ch+1)+' '+(st.inst||'')+' üîí'; }); ctl.appendChild(sel); const lock=document.createElement('label'); const cb=document.createElement('input'); cb.type='checkbox'; cb.checked=st.locked; cb.addEventListener('change',(e)=>{ st.locked=e.target.checked; strip.title=(ch+1)+' '+(st.inst||'')+(st.locked?' üîí':''); }); lock.appendChild(cb); lock.appendChild(document.createTextNode('üîí')); ctl.appendChild(lock); const m=document.createElement('label'); const mcb=document.createElement('input'); mcb.type='checkbox'; mcb.checked=st.mute; mcb.addEventListener('change',(e)=>{ st.mute=e.target.checked; updateMixGains(); }); m.appendChild(mcb); m.appendChild(document.createTextNode('M')); m.className='muted'; ctl.appendChild(m); const s=document.createElement('label'); const scb=document.createElement('input'); scb.type='checkbox'; scb.checked=st.solo; scb.addEventListener('change',(e)=>{ st.solo=e.target.checked; updateMixGains(); }); s.appendChild(scb); s.appendChild(document.createTextNode('S')); s.className='solo'; ctl.appendChild(s); controls.appendChild(ctl); strip.appendChild(controls); grid.appendChild(strip); } mixerBuilt=true; refreshMixerCounters(true); }
  function refreshMixerCounters(force=false){ const now=audioCtx? audioCtx.currentTime:0; let usedCount=0, activeNow=0; for(let ch=0; ch<16; ch++){ const a=chAct[ch]; const isActiveNow=(now - (a.last||0)) < 1.2 || (a.level>0.02); if(isActiveNow) activeNow++; if(chSeen[ch]) usedCount++; } const usedEl=document.getElementById('usedSummary'); const actEl=document.getElementById('activeSummary'); if(force || usedEl._val!==usedCount){ usedEl.textContent='Used '+usedCount+'/16'; usedEl._val=usedCount; } if(force || actEl._val!==activeNow){ actEl.textContent='Now '+activeNow; actEl._val=activeNow; } }
  function updateMixerMeters(){ for(let ch=0; ch<16; ch++){ const a=chAct[ch]; const bar=meterBars[ch]; if(!bar) continue; const h=Math.min(100, Math.floor((a.level||0)*100)); if(bar._h!==h){ bar.style.height=h+'%'; bar._h=h; } } refreshMixerCounters(); }

  function bindUI(){ document.getElementById('btnInit').addEventListener('click', initAudio); document.getElementById('midFiles').addEventListener('change', onAddFiles); document.getElementById('btnPlay').addEventListener('click', ()=>startPlayback(true)); document.getElementById('btnStop').addEventListener('click', stopPlayback); document.getElementById('btnPanic').addEventListener('click', panicAll); document.getElementById('btnCalm').addEventListener('click', applyCalm); document.getElementById('preset').addEventListener('change', (e)=>{ settings.ui.preset=e.target.value; persistSettings(); applyPreset(settings.ui.preset); }); document.getElementById('limStr').addEventListener('input', (e)=>{ settings.audio.limiter=parseFloat(e.target.value||'0.78'); persistSettings(); onLimiter(); }); document.getElementById('notch').addEventListener('change', (e)=>{ settings.audio.notch=parseFloat(e.target.value||'0'); persistSettings(); onNotch(); }); (() => { const ss = document.getElementById('softSynth'); if (ss) ss.addEventListener('change', (e)=>{ useTriangle=e.target.checked; log('Soft Synth '+(useTriangle?'ON':'OFF')); }); const ab = document.getElementById('antiBeep'); if (ab) ab.addEventListener('change', (e)=>{ antiBeep=e.target.checked; log('Anti‚ÄëBeep '+(antiBeep?'ON':'OFF')); }); })(); const palSel = document.getElementById('palette'); if (palSel) palSel.addEventListener('change', (e)=>{ settings.ui.palette = e.target.value; persistSettings(); palette = settings.ui.palette; log('Palette '+palette); for (let ch=0; ch<16; ch++) { if (!channels[ch].locked) maybeAutoAssign(ch); titleBadges[ch].textContent=instSymbol(channels[ch].inst); } }); for (let i=0;i<10;i++){ const el=document.getElementById('eq10_'+i); if(el) el.addEventListener('input', onEq10Slider); } document.getElementById('density').addEventListener('change',(e)=>{ settings.ui.density=e.target.value; persistSettings(); applyDensity(settings.ui.density); }); document.getElementById('fit16').addEventListener('change',(e)=>{ settings.ui.fit16 = e.target.checked; persistSettings(); fit16Active = settings.ui.fit16; autoFit16(); }); window.addEventListener('resize', ()=>{ setupVizCanvas(); if(fit16Active) autoFit16(); }); const list=document.getElementById('plList'); const onListTap=(e)=>{ const item=e.target.closest('.plItem'); if(!item) return; selectTrack(+item.dataset.index); }; list.addEventListener('click', onListTap); list.addEventListener('touchstart', onListTap, {passive:true}); document.getElementById('btnResetUsed').addEventListener('click', ()=>{ for(let i=0;i<16;i++){ chSeen[i]=false; chAct[i].level=0; chAct[i].last=0; } refreshMixerCounters(true); updateMixerMeters(); }); document.getElementById('btnRecNow').addEventListener('click', ()=>startRecording('current')); document.getElementById('btnRecRestart').addEventListener('click', ()=>startRecording('restart')); document.getElementById('btnRecStop').addEventListener('click', stopRecording); document.getElementById('solfEnable').addEventListener('change', (e)=>{ settings.audio.solfEnable = !!e.target.checked; persistSettings(); solfEnable = settings.audio.solfEnable; log('Solfeggio '+(solfEnable?'ON':'OFF')); updateSolfeggio(); }); document.getElementById('solfType').addEventListener('change', (e)=>{ settings.audio.solfType = e.target.value; persistSettings(); solfType = settings.audio.solfType; log('Solf Type '+solfType); updateSolfeggio(true); }); document.getElementById('solfFreq').addEventListener('change', (e)=>{ settings.audio.solfFreq = parseFloat(e.target.value||'528'); persistSettings(); solfFreq = settings.audio.solfFreq; log('Solf Freq '+solfFreq+' Hz'); updateSolfeggio(); }); document.getElementById('solfLevel').addEventListener('input', (e)=>{ const v=parseFloat(e.target.value||'0.12'); settings.audio.solfLevel=v; persistSettings(); if(solfGainNode) try{ solfGainNode.gain.setTargetAtTime(v, audioCtx.currentTime, 0.05); }catch(err){} }); document.getElementById('tuneEnable').addEventListener('change', (e)=>{ settings.audio.tuneEnable = !!e.target.checked; persistSettings(); tuneEnable = settings.audio.tuneEnable; updateRetune(); log('Retune '+(tuneEnable?'ON':'OFF')); }); document.getElementById('tuneFreq').addEventListener('change', (e)=>{ settings.audio.tuneFreq = parseFloat(e.target.value||'528'); persistSettings(); tuneFreq = settings.audio.tuneFreq; updateRetune(); log('Retune target '+tuneFreq+' Hz'); }); document.getElementById('contMode').addEventListener('change', (e)=>{ settings.ui.contMode = e.target.value; persistSettings(); contMode = settings.ui.contMode; log('Continuous '+contMode); }); const asnSel=document.getElementById('autoAssign'); if(asnSel) asnSel.addEventListener('change',(e)=>{ settings.ui.autoAssign = (e.target.value==='1'); persistSettings(); autoAssign = settings.ui.autoAssign; log('Assign '+(autoAssign?'ON':'OFF')); }); const recSel=document.getElementById('autoRecovery'); if(recSel) recSel.addEventListener('change',(e)=>{ settings.ui.autoRecovery = (e.target.value==='1'); persistSettings(); autoRecovery = settings.ui.autoRecovery; log('Recovery '+(autoRecovery?'ON':'OFF')); }); (function(){ const srcSel = document.getElementById('lySrc'); const cbPres = document.getElementById('lyPreserve'); const cbSlash = document.getElementById('lySplitSlash'); const encSel = document.getElementById('lyEnc'); const btnFull = document.getElementById('btnLyFull'); const btnTok  = document.getElementById('btnLyTokens'); srcSel.addEventListener('change', async (e)=>{ settings.lyrics.source = e.target.value || '05'; persistSettings(); lyrics.source=settings.lyrics.source; const ok = await ensureParsed(); if (ok) renderLyricsStatic(); }); cbPres.addEventListener('change', async (e)=>{ settings.lyrics.preserveSpaces = !!e.target.checked; persistSettings(); lyrics.preserveSpaces=settings.lyrics.preserveSpaces; const ok = await ensureParsed(); if (ok) renderLyricsStatic(); }); cbSlash.addEventListener('change', async (e)=>{ settings.lyrics.splitOnSlash = !!e.target.checked; persistSettings(); lyrics.splitOnSlash=settings.lyrics.splitOnSlash; const ok = await ensureParsed(); if (ok) renderLyricsStatic(); }); encSel.addEventListener('change', async (e)=>{ settings.lyrics.enc = e.target.value || 'latin1'; persistSettings(); lyrics.enc=settings.lyrics.enc; const ok = await ensureParsed(); if (ok) renderLyricsStatic(); }); btnFull.addEventListener('click', ()=>{ document.getElementById('lyFull').style.display='block'; document.getElementById('lyTokens').style.display='none'; }); btnTok .addEventListener('click',  ()=>{ document.getElementById('lyFull').style.display='none';  document.getElementById('lyTokens').style.display='block'; }); srcSel.value = settings.lyrics.source; cbPres.checked = settings.lyrics.preserveSpaces; cbSlash.checked = settings.lyrics.splitOnSlash; encSel.value = settings.lyrics.enc; })(); (function(){ const win = document.getElementById('winKaro'); function setAlign(v){ win.classList.toggle('karo-align-left',  v==='left'); win.classList.toggle('karo-align-center',v==='center'); KaroState.align=v; settings.karaoke.align=v; persistSettings(); } function setFill(v){ win.style.setProperty('--kara-fill', v||'#00b3ff'); settings.karaoke.fill=v; persistSettings(); } function setBase(v){ win.style.setProperty('--kara-base', v||'#ffffff'); settings.karaoke.base=v; persistSettings(); } function setBg(v){   win.style.setProperty('--kara-bg',   v||'rgba(0,0,0,0)'); settings.karaoke.bg=v; persistSettings(); } function setGlow(n){ win.style.setProperty('--glow-radius',  String(n||0)+'px'); win.style.setProperty('--glow-radius2', String((n||0)*1.4)+'px'); settings.karaoke.glow=n; persistSettings(); } function setStrokeW(n){ win.style.setProperty('--kara-stroke-w', String(Math.max(0,n||0))+'px'); settings.karaoke.strokeW=n; persistSettings(); } function setBlend(v){ win.style.setProperty('--kara-blend', v||'normal'); settings.karaoke.blend=v; persistSettings(); } function setWeight(n){ win.style.setProperty('--kara-weight', String(n||800)); settings.karaoke.weight=n; persistSettings(); } function setLS(n){    win.style.setProperty('--kara-letter-spacing', String(n||0)+'em'); settings.karaoke.letterSpacing=n; persistSettings(); } function setGap(n){   win.style.setProperty('--kara-token-gap', String(n||0)+'em'); settings.karaoke.tokenGap=n; persistSettings(); } function setCase(v){  KaroState.case = v||'none'; settings.karaoke.case=v; persistSettings(); } function setChromaSafe(b){ win.classList.toggle('karo-chroma-safe', !!b); settings.karaoke.chromaSafe=!!b; persistSettings(); } function setMicroStroke(b){ win.classList.toggle('karo-micro-stroke', !!b); settings.karaoke.microStroke=!!b; persistSettings(); } const $ = (id)=>document.getElementById(id); $('karoAlign').addEventListener('change',(e)=>setAlign(e.target.value)); $('karoLettersOnly').addEventListener('change',(e)=>{ KaroState.lettersOnly = !!e.target.checked; settings.karaoke.lettersOnly=!!e.target.checked; persistSettings(); }); $('karoChromaSafe').addEventListener('change',(e)=>setChromaSafe(e.target.checked)); $('karoMicroStroke').addEventListener('change',(e)=>setMicroStroke(e.target.checked)); $('karoFill').addEventListener('input',(e)=>setFill(e.target.value)); $('karoBase').addEventListener('input',(e)=>setBase(e.target.value)); $('karoBg').addEventListener('input',(e)=>setBg(e.target.value)); $('karoGlow').addEventListener('input',(e)=>setGlow(parseFloat(e.target.value||'0'))); $('karoStrokeW').addEventListener('input',(e)=>setStrokeW(parseFloat(e.target.value||'0'))); $('karoBlend').addEventListener('change',(e)=>setBlend(e.target.value)); $('karoWeight').addEventListener('input',(e)=>setWeight(parseInt(e.target.value||'800',10))); $('karoLS').addEventListener('input',(e)=>setLS(parseFloat(e.target.value||'0'))); $('karoGap').addEventListener('input',(e)=>setGap(parseFloat(e.target.value||'0'))); $('karoCase').addEventListener('change',(e)=>setCase(e.target.value)); setAlign(settings.karaoke.align); setChromaSafe(settings.karaoke.chromaSafe); setMicroStroke(settings.karaoke.microStroke); setFill(settings.karaoke.fill); setBase(settings.karaoke.base); setBg(settings.karaoke.bg); setGlow(settings.karaoke.glow); setStrokeW(settings.karaoke.strokeW); setBlend(settings.karaoke.blend); setWeight(settings.karaoke.weight); setLS(settings.karaoke.letterSpacing); setGap(settings.karaoke.tokenGap); setCase(settings.karaoke.case); $('karoLettersOnly').checked = settings.karaoke.lettersOnly; $('karoAlign').value = settings.karaoke.align; $('karoChromaSafe').checked = settings.karaoke.chromaSafe; $('karoMicroStroke').checked = settings.karaoke.microStroke; $('karoFill').value = settings.karaoke.fill; $('karoBase').value = settings.karaoke.base; $('karoBg').value   = settings.karaoke.bg; $('karoGlow').value = settings.karaoke.glow; $('karoStrokeW').value = settings.karaoke.strokeW; $('karoBlend').value= settings.karaoke.blend; $('karoWeight').value = settings.karaoke.weight; $('karoLS').value = settings.karaoke.letterSpacing; $('karoGap').value= settings.karaoke.tokenGap; $('karoCase').value= settings.karaoke.case; (function(){ const cb = document.getElementById('karoAOD'); cb.checked = !!settings.karaoke.aod; let wakeLock = null, fallbackVideo=null; async function requestWL(){ if(!('wakeLock' in navigator)){ fallback(); return; } try{ wakeLock = await navigator.wakeLock.request('screen'); wakeLock.addEventListener('release', ()=>{ wakeLock=null; }); }catch(err){ fallback(); } } async function releaseWL(){ try{ await wakeLock?.release?.(); }catch(_){} wakeLock=null; if(fallbackVideo){ try{ fallbackVideo.pause(); }catch(_){} fallbackVideo.remove(); fallbackVideo=null; } } function fallback(){ if(fallbackVideo) return; const ac = audioCtx || new (window.AudioContext||window.webkitAudioContext)(); const osc = ac.createOscillator(); osc.frequency.value = 0.0001; const gain = ac.createGain(); gain.gain.value = 0.0; osc.connect(gain).connect(ac.destination); osc.start(); fallbackVideo = document.createElement('audio'); fallbackVideo.muted = true; fallbackVideo.loop = true; fallbackVideo.playsInline = true; fallbackVideo.style.position='fixed'; fallbackVideo.style.width='1px'; fallbackVideo.style.height='1px'; fallbackVideo.style.opacity='0'; fallbackVideo.style.pointerEvents='none'; document.body.appendChild(fallbackVideo); fallbackVideo.src = 'data:audio/wav;base64,UklGRgAAAAAA'; fallbackVideo.play().catch(()=>{}); } if(cb){ cb.addEventListener('change', async (e)=>{ const on = !!e.target.checked; settings.karaoke.aod = on; persistSettings(); if(on) await requestWL(); else await releaseWL(); }); } document.addEventListener('visibilitychange', async ()=>{ if(document.visibilityState==='visible' && cb && cb.checked){ await requestWL(); } }); })(); })(); (function(){ const fsBtn=document.getElementById('btnKaroFS'); const win=document.getElementById('winKaro'); function toggleFS(){ if(!document.fullscreenElement){ win.requestFullscreen?.(); } else { document.exitFullscreen?.(); } } fsBtn.addEventListener('click', toggleFS); document.addEventListener('fullscreenchange',()=>{ const active = !!document.fullscreenElement; fsBtn.textContent = active? '‚§¢' : '‚õ∂'; fsBtn.setAttribute('aria-pressed', active? 'true':'false'); }); })(); document.getElementById('density').value = settings.ui.density; applyDensity(settings.ui.density); fit16Active = settings.ui.fit16; document.getElementById('fit16').checked = settings.ui.fit16; if(fit16Active) autoFit16(); document.getElementById('palette').value = settings.ui.palette; palette = settings.ui.palette; document.getElementById('preset').value = settings.ui.preset; applyPreset(settings.ui.preset); document.getElementById('limStr').value = settings.audio.limiter; onLimiter(); document.getElementById('notch').value = settings.audio.notch; onNotch(); document.getElementById('contMode').value = settings.ui.contMode; contMode=settings.ui.contMode; document.getElementById('autoAssign').value = settings.ui.autoAssign? '1':'0'; autoAssign=settings.ui.autoAssign; document.getElementById('autoRecovery').value = settings.ui.autoRecovery? '1':'0'; autoRecovery=settings.ui.autoRecovery; document.getElementById('solfEnable').checked = settings.audio.solfEnable; solfEnable=settings.audio.solfEnable; document.getElementById('solfType').value = settings.audio.solfType; solfType=settings.audio.solfType; document.getElementById('solfFreq').value = String(settings.audio.solfFreq); solfFreq=settings.audio.solfFreq; document.getElementById('solfLevel').value = String(settings.audio.solfLevel); document.getElementById('tuneEnable').checked = settings.audio.tuneEnable; tuneEnable=settings.audio.tuneEnable; document.getElementById('tuneFreq').value = String(settings.audio.tuneFreq); tuneFreq=settings.audio.tuneFreq; applySavedWindows(); buildMixerOnce();

  // ADD: init audio-only state
  const audioOnlyCB = document.getElementById('audioOnly');
  if (audioOnlyCB){
    audioOnlyCB.addEventListener('change', (e)=>{
      settings.ui.audioOnly = !!e.target.checked;
      persistSettings();
      applyAudioOnlyUI(settings.ui.audioOnly);
      log('Audio‚Äëonly ' + (settings.ui.audioOnly ? 'ON' : 'OFF'));
    });
    audioOnlyCB.checked = !!settings.ui.audioOnly;
    applyAudioOnlyUI(!!settings.ui.audioOnly);
  }
}
  if(document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', bindUI); } else { bindUI(); }

  function applySavedWindows(){ if(!settings.windows) return; for(const id in settings.windows){ const w=document.getElementById(id); if(!w) continue; const st=settings.windows[id]; if(st.left) w.style.left=st.left; if(st.top) w.style.top=st.top; if(st.width) w.style.width=st.width; if(st.display) w.style.display=st.display; } }
  let fit16Active = true; function applyDensity(mode){ const body=document.body; body.classList.remove('density-ultra','density-compact','density-normal'); body.classList.add('density-'+mode); if(fit16Active) autoFit16(); }
  function autoFit16(){ const grid=document.getElementById('chGridVert'); const gap=parseInt(getComputedStyle(grid).gap)||6; const W=window.innerWidth - 16; const min=48; const col = Math.max(min, Math.floor((W - gap*(16-1))/16)); document.documentElement.style.setProperty('--stripW', col+'px'); const meterH=Math.max(56, Math.floor(col*1.05)); document.documentElement.style.setProperty('--meterH', meterH+'px'); document.documentElement.style.setProperty('--meterW', Math.max(4, Math.floor(col*0.10))+'px'); }

  function initAudioChain(){ masterIn = audioCtx.createGain(); masterIn.gain.value=1.0; eqBands = EQ_FREQS.map((f,idx)=>{ const b=audioCtx.createBiquadFilter(); b.type=(idx===0?'lowshelf':(idx===9?'highshelf':'peaking')); if(b.type==='peaking') b.Q.value=1.0; b.frequency.value=f; const val=parseFloat(document.getElementById('eq10_'+idx)?.value||'0'); b.gain.value=val; return b; }); hpf = audioCtx.createBiquadFilter(); hpf.type='highpass'; hpf.frequency.value=28; notch = audioCtx.createBiquadFilter(); notch.type='notch'; const notchSel = parseFloat(document.getElementById('notch')?.value||'0'); notch.frequency.value=(notchSel>0 ? notchSel : 1000); notch.Q.value=(notchSel>0 ? 28 : 0.0001); clip = audioCtx.createWaveShaper(); clip.curve = makeSoftClipCurve(parseFloat(document.getElementById('limStr')?.value||'0.78')); clip.oversample='4x'; analyser = audioCtx.createAnalyser(); analyser.fftSize = 2048; analyser.smoothingTimeConstant = 0.85; transport = audioCtx.createGain(); transport.gain.value=1.0; masterOut = audioCtx.destination; mediaDest = audioCtx.createMediaStreamDestination(); let node=masterIn; for(const b of eqBands){ node.connect(b); node=b; } node.connect(hpf).connect(notch).connect(clip); // final wiring below
  // Initial wiring respects Audio-only
  drawVizEnabled  = !settings.ui.audioOnly;
  goertzelEnabled = !settings.ui.audioOnly;
  analyserBypassed = !!settings.ui.audioOnly;
  wireFinalStage(!analyserBypassed);
  solfGainNode = audioCtx.createGain(); solfGainNode.gain.value = parseFloat(document.getElementById('solfLevel')?.value||'0.12'); solfGainNode.connect(transport);
  for(let ch=0; ch<16; ch++){ const g=audioCtx.createGain(); g.gain.value=0.0; channels[ch].gain=g; g.connect(masterIn); }
  setupVizCanvas(); _vizRAF = requestAnimationFrame(drawWave); updateRetune(); _goertzelRAF = requestAnimationFrame(goertzelDetectLoop);
}
  function setupVizCanvas(){ vizCanvas=document.getElementById('mainViz'); if(!vizCanvas) return; const dpr=window.devicePixelRatio||1; const cssW=vizCanvas.clientWidth||window.innerWidth; const cssH=vizCanvas.clientHeight||84; vizCanvas.width=Math.floor(cssW*dpr); vizCanvas.height=Math.floor(cssH*dpr); vizCtx=vizCanvas.getContext('2d'); vizCtx.setTransform(dpr,0,0,dpr,0,0); vizBuffer=new Uint8Array(analyser? analyser.fftSize : 2048);
   // NEW: float time-domain buffer for Goertzel
  vizBufferF=new Float32Array(analyser ? analyser.fftSize : 2048);
  }
  
  function drawWave(){
    if(!vizCtx){ requestAnimationFrame(drawWave); return; }
    if(!drawVizEnabled){ return; } // gate in audio-only
    const W=vizCanvas.width/(window.devicePixelRatio||1), H=vizCanvas.height/(window.devicePixelRatio||1);
    vizCtx.fillStyle='#0a1220'; vizCtx.fillRect(0,0,W,H);
    vizCtx.strokeStyle='#00b3ff'; vizCtx.lineWidth=1.4; vizCtx.beginPath();
    if(analyser){ analyser.getByteTimeDomainData(vizBuffer); const step = (vizBuffer.length-1) / (W-2); for(let x=0;x<W;x++){ const idx = Math.min(vizBuffer.length-1, Math.floor(x*step)); const v = (vizBuffer[idx]-128)/128; const y = H*0.5 + v*(H*0.42); if(x===0) vizCtx.moveTo(x+1,y); else vizCtx.lineTo(x+1,y); } } else { vizCtx.moveTo(0,H*0.5); vizCtx.lineTo(W,H*0.5); }
    vizCtx.stroke(); vizCtx.strokeStyle='#24344e'; vizCtx.lineWidth=1; vizCtx.beginPath(); vizCtx.moveTo(0,H*0.5); vizCtx.lineTo(W,H*0.5); vizCtx.stroke();
    if(drawVizEnabled) requestAnimationFrame(drawWave);
  }

// === Goertzel single-bin detector (power at target frequency) ===
function goertzelPower(samples, sampleRate, targetHz){
  const N = samples.length;
  if (!N || !sampleRate || !isFinite(sampleRate) || !isFinite(targetHz)) return 0;

  const k = Math.round((targetHz / sampleRate) * N);
  const w = (2*Math.PI*k)/N;
  const cosW = Math.cos(w), sinW = Math.sin(w);

  let s_prev = 0.0, s_prev2 = 0.0;
  for (let i=0; i<N; i++){
    const x = samples[i];
    const s = x + 2*cosW*s_prev - s_prev2;
    s_prev2 = s_prev;
    s_prev  = s;
  }

  const real = s_prev - s_prev2*cosW;
  const imag = s_prev2*sinW;
  const power = (real*real + imag*imag) / N; // normalized
  return power;
}

function goertzelDetectLoop(){
  if (!goertzelEnabled) { return; } // gate in audio-only
  try{
    if (!audioCtx || !analyser || !vizBufferF){
      if (goertzelEnabled) _goertzelRAF = requestAnimationFrame(goertzelDetectLoop);
      return;
    }

    analyser.getFloatTimeDomainData(vizBufferF);

    if (solfEnable){
      const sr = audioCtx.sampleRate || 48000;
      const targ = solfFreq || 528;
      const p = goertzelPower(vizBufferF, sr, targ);
      const db = 10 * Math.log10(Math.max(1e-12, p));
      const chip = document.getElementById('solfDetect');
      if (chip){
       
const levelColor = (db > -20) ? '#17c964' : (db > -30) ? '#f5a524' : '#9fbad1';
  chip.textContent = '';                     // no text
  chip.style.color = '';                     // ignore text color
  chip.style.backgroundColor = levelColor;   // dot color

      }
 } else {


const chipS = document.getElementById('solfDetect');
if (chipS){
  chipS.textContent = '';
  chipS.style.backgroundColor = '#9fbad1';
}

         }

    
    // Retune detection
    if (tuneEnable){
      const sr   = audioCtx.sampleRate || 48000;
      const targ = tuneFreq || 528;
      const p  = goertzelPower(vizBufferF, sr, targ);
      const db = 10 * Math.log10(Math.max(1e-12, p));
      const chip = document.getElementById('tuneDetect');
      if (chip){
        
const levelColor = (db > -20) ? '#17c964' : (db > -30) ? '#f5a524' : '#9fbad1';
  chip.textContent = '';                     // no text
  chip.style.color = '';                     // ignore text color
  chip.style.backgroundColor = levelColor;   // dot color

      }
    } else {

const chip = document.getElementById('tuneDetect');
if (chip){
  chip.textContent = '';
  chip.style.backgroundColor = '#9fbad1';
}

         }
  }catch(e){
    try{ log('Goertzel error: ' + (e.message||e)); }catch(_){}
  }

  if (goertzelEnabled) _goertzelRAF = requestAnimationFrame(goertzelDetectLoop);
}
  
  async function initAudio(){ if(!audioCtx){ audioCtx = new (window.AudioContext||window.webkitAudioContext)(); initAudioChain(); requestAnimationFrame(chRenderLoop); requestAnimationFrame(voiceWatchdogLoop); } try{ await audioCtx.resume(); }catch(e){} log('Audio ready.'); document.getElementById('btnStop').disabled=true; document.getElementById('btnPlay').disabled = !(playlist.length>0 && currentIndex>=0); document.getElementById('btnPanic').disabled=false; }

  function stopSolfOscs(){ const t=audioCtx?.currentTime||0; const list=[solfOscL, solfOscR]; for(const o of list){ try{ o && o.stop(t+0.01); o && o.disconnect?.(); }catch(e){} if(o){ o.started=false; o._connected=false; } } if(solfPanL) try{ solfPanL.disconnect(); }catch(e){} if(solfPanR) try{ solfPanR.disconnect(); }catch(e){} solfOscL=null; solfOscR=null; solfPanL=null; solfPanR=null; }
  function updateSolfeggio(forceRebuild=false){ if(!audioCtx || !solfGainNode) return; const t=audioCtx.currentTime; if(!solfEnable){ stopSolfOscs(); try{ solfGainNode.gain.setTargetAtTime(0.0, t, 0.10); }catch(e){} return; } if(forceRebuild){ stopSolfOscs(); } const lvl = parseFloat(document.getElementById('solfLevel')?.value||'0.12'); try{ solfGainNode.gain.setTargetAtTime(lvl, t, 0.08); }catch(e){} if(solfType==='binaural'){ if(!solfOscL){ solfOscL = audioCtx.createOscillator(); solfOscL.type='sine'; } if(!solfOscR){ solfOscR = audioCtx.createOscillator(); solfOscR.type='sine'; } if(!solfPanL && audioCtx.createStereoPanner){ solfPanL = audioCtx.createStereoPanner(); solfPanL.pan.value=-1; } if(!solfPanR && audioCtx.createStereoPanner){ solfPanR = audioCtx.createStereoPanner(); solfPanR.pan.value=+1; } const delta = BEAT_DELTA_HZ; const fL = Math.max(20, solfFreq - delta/2); const fR = Math.max(20, solfFreq + delta/2); try{ solfOscL.frequency.setValueAtTime(fL, t); solfOscR.frequency.setValueAtTime(fR, t); }catch(e){} if(!solfOscL._connected){ try{ solfOscL.connect(solfPanL||solfGainNode); if(solfPanL) solfPanL.connect(solfGainNode); solfOscL._connected=true; }catch(e){} } if(!solfOscR._connected){ try{ solfOscR.connect(solfPanR||solfGainNode); if(solfPanR) solfPanR.connect(solfGainNode); solfOscR._connected=true; }catch(e){} } if(!solfOscL.started){ try{ solfOscL.start(t+0.01); solfOscL.started=true; }catch(e){} } if(!solfOscR.started){ try{ solfOscR.start(t+0.01); solfOscR.started=true; }catch(e){} } } else { if(!solfOscL){ solfOscL = audioCtx.createOscillator(); solfOscL.type='sine'; } try{ solfOscL.frequency.setValueAtTime(Math.max(20, solfFreq), t); }catch(e){} if(!solfOscL._connected){ try{ solfOscL.connect(solfGainNode); solfOscL._connected=true; }catch(e){} } if(!solfOscL.started){ try{ solfOscL.start(t+0.01); solfOscL.started=true; }catch(e){} } if(solfOscR){ try{ solfOscR.stop(t+0.01); solfOscR.disconnect(); }catch(e){} solfOscR=null; } if(solfPanL){ try{ solfPanL.disconnect(); }catch(e){} solfPanL=null; } if(solfPanR){ try{ solfPanR.disconnect(); }catch(e){} solfPanR=null; } } }

  function midiToFreq(m){ return 440*Math.pow(2,(m-69)/12); }
  function nearestMidiNoteForFreq(f){ return Math.max(0, Math.min(127, Math.round(69 + 12*Math.log2(f/440)))); }
  function updateRetune(){ if(!audioCtx) return; if(!tuneEnable){ globalDetuneRatio = 1.0; return; } const target = tuneFreq||528; const midi = nearestMidiNoteForFreq(target); const std = midiToFreq(midi); globalDetuneRatio = Math.max(0.25, Math.min(4.0, target / std)); log(`Retune: target ${target} Hz ~ MIDI ${midi} (${std.toFixed(2)} Hz) ‚Üí ratio ${globalDetuneRatio.toFixed(6)}`); }

  function startRecording(mode){ if(!audioCtx){ log('Init Audio first'); return; } if(!mediaDest){ log('Recording not available'); return; } if(mediaRecorder && mediaRecorder.state==='recording'){ log('Already recording'); return; } recChunks=[]; const preferred = (window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) ? 'audio/webm;codecs=opus' : 'audio/webm'; try{ mediaRecorder = new MediaRecorder(mediaDest.stream, {mimeType: preferred}); }catch(e){ log('Recorder init failed: '+(e.message||e)); return; } mediaRecorder.ondataavailable = (e)=>{ if(e.data && e.data.size>0) recChunks.push(e.data); }; mediaRecorder.onstop = ()=>{ const blob = new Blob(recChunks, {type: preferred}); const url = URL.createObjectURL(blob); const dl = document.getElementById('recDownload'); const name = 'mix_'+new Date().toISOString().replace(/[:.]/g,'-')+'.webm'; dl.href=url; dl.download=name; dl.style.display='inline-block'; log('Recording ready: '+name); setTimeout(()=>{ try{ URL.revokeObjectURL(url); }catch(_){} }, 5*60*1000); }; mediaRecorder.start(); document.getElementById('btnRecStop').disabled=false; log('‚è∫ Recording '+(mode==='restart'?'(restart)':'(current)')); if(mode==='restart'){ stopPlayback(); ensureParsed().then((ok)=>{ if(ok){ startPlayback(true); } }); } }
  function stopRecording(){ if(mediaRecorder && mediaRecorder.state==='recording'){ try{ mediaRecorder.stop(); }catch(e){} } document.getElementById('btnRecStop').disabled=true; }

  function onLimiter(){ if(!clip) return; const k=parseFloat(document.getElementById('limStr').value||'0.78'); clip.curve=makeSoftClipCurve(k); log('Limiter '+k); }
  function onNotch(){ if(!notch) return; const v=parseFloat(document.getElementById('notch').value||'0'); notch.frequency.value=(v>0? v:1000); notch.Q.value=(v>0? 28:0.0001); log('Notch '+(v>0? v+' Hz':'Off')); }
  function onEq10Slider(){ if(!eqBands?.length) return; for(let i=0;i<10;i++){ const v=parseFloat(document.getElementById('eq10_'+i)?.value||'0'); eqBands[i].gain.value=v; } }
  function applyPreset(name){ const map={ 'Flat':[0,0,0,0,0,0,0,0,0,0], 'Warm':[3,2,1,0,-1,-1,-2,-3,-4,-5], 'Bright':[-2,-1,0,1,2,2,2,3,4,5], 'Vocal':[-3,-2,-1,0,1,2,3,2,1,0], 'BassBoost':[6,4,2,0,-1,-2,-2,-2,-3,-4], 'BassStrong':[8,6,4,1,0,-1,-2,-3,-4,-5] }[name]||[0,0,0,0,0,0,0,0,0,0]; for(let i=0;i<10;i++){ const el=document.getElementById('eq10_'+i); if(el){ el.value=map[i]; } } onEq10Slider(); log('Preset '+name); }
  function applyCalm(){ applyPreset('Warm'); const lim=document.getElementById('limStr'); if(lim){ lim.value=0.78; settings.audio.limiter=0.78; persistSettings(); } onLimiter(); log('Calm applied'); }

  async function onAddFiles(e){ const files=Array.from(e.target.files||[]); if(!files?.length){ log('No files from picker. Choose files stored "On this device".'); return; } addFiles(files); }
  function addFiles(files){ const list=Array.from(files||[]); for(const f of list){ const name=f.name || 'file.mid'; playlist.push({ name, file:f, parsed:false, tempo:null, events:null, lyrics:null }); } updatePlaylistUI(); if(currentIndex===-1){ selectTrack(0); } document.getElementById('btnPlay').disabled=false; document.getElementById('btnStop').disabled=false; log('Files added: '+list.length+'.'); }
function updatePlaylistUI(){
  const list = document.getElementById('plList');
  list.innerHTML = '';

  if (playlist.length === 0){
    list.innerHTML = '<div class="plItem">(No items)</div>';
    return;
  }

  playlist.forEach((t,i)=>{
    const row = document.createElement('div');
    row.className = 'plItem' + (i===currentIndex ? ' active' : '');
    row.dataset.index = i;
    row.title = 'Tap to select';

    const label = document.createElement('span');
    label.textContent = (i+1) + '. ' + t.name + (t.parsed ? '' : ' (lazy)');

    const playBtn = document.createElement('button');
    playBtn.className = 'btn';
    playBtn.type = 'button';
    playBtn.textContent = '‚ñ∂';
    playBtn.title = 'Play';

    playBtn.addEventListener('click', async (ev)=>{
      ev.stopPropagation();
      selectTrack(i);
      const mainPlay = document.getElementById('btnPlay');
      if (mainPlay && !mainPlay.disabled) {
        mainPlay.click();
      } else {
        if (!audioCtx) await initAudio();
        await startPlayback(true);
      }
      const winPl  = document.getElementById('winPlaylist');
      const winKar = document.getElementById('winKaro');
      if (winPl)  winPl.style.display = 'none';
      if (winKar) { 
        winKar.style.display = 'block'; 
        winKar.style.zIndex  = (++zCounter).toString(); 
      }
    });

    row.addEventListener('click', ()=>{ selectTrack(i); }, { passive:true });

    row.appendChild(label);
    row.appendChild(playBtn);
    list.appendChild(row);
  });

  document.getElementById('btnStop').disabled = (playlist.length === 0);
}

  function resetStateForNewTrack(){ for(let ch=0; ch<16; ch++){ chAct[ch].level=0; chAct[ch].last=0; chSeen[ch]=false; channels[ch].prog=null; } seq.ptr=0; seq.startTick=0; seq.running=false; if(seq.timer){ clearInterval(seq.timer); seq.timer=null; } refreshMixerCounters(true); updateMixerMeters(); }
  function selectTrack(i){ if(i<0||i>=playlist.length) return; currentIndex=i; hardResetAudio(); resetStateForNewTrack();   
  if (solfEnable && solfGainNode) { try { updateSolfeggio(true); } catch(e){} }
  if (!audioOnly){ try { LyricsLive.rebuild(); Karo.rebuild(); }catch(_){} }
  const song=playlist[i]; _tempo=song.tempo; seq.events=song.events||[]; updatePlaylistUI(); document.getElementById('btnPlay').disabled=false; document.getElementById('btnStop').disabled=false; log('Selected: '+song.name+(song.parsed?' ‚Ä¢ parsed':' ‚Ä¢ lazy'));document.getElementById('currentTitle').textContent = playlist[i].name || '(Unknown title)';

  if (song.lyrics) { lyrics.json = song.lyrics; renderLyricsStatic(); LyricsLive.rebuild(); Karo.rebuild(); } }

  function tickToSec(t){ return _tempo ? _tempo.tickToSec(t) : (t/480)*0.5; }
  async function ensureParsed(){ const song=playlist[currentIndex]; if(!song) return false; if(song.parsed){ return true; }
    try{ const buf=await song.file.arrayBuffer(); const u8=new Uint8Array(buf); const smf=parseSMF(u8); const tempo=buildTempoMap(smf); const evs=collectEvents(smf); song.tempo=tempo; song.events=evs; song.parsed=true; _tempo=tempo; seq.events=evs; updatePlaylistUI(); log('Parsed: '+song.name+' ‚Ä¢ events '+evs.length);
      try { const metaEvs = collectMetaLyrics(smf); const allow = (lyrics.source==='05') ? [0x05] : (lyrics.source==='05+01' ? [0x05,0x01] : [0x05,0x01,0x03]); const opts  = { preserveSpaces: lyrics.preserveSpaces, splitOnSlash: lyrics.splitOnSlash, enc: lyrics.enc }; const json  = buildLyricsJSON(metaEvs, tempo.tickToSec, allow, opts); song.lyrics = json; lyrics.json = json; } catch(err) { log('Lyrics parse note: '+(err.message||err)); }
      return true;
    }catch(err){ log('Parse error ('+song.name+'): '+(err.message||err)); return false; }
  }
  async function startPlayback(withGap=false){ if(!audioCtx){ log('Init Audio first'); return; } const ok=await ensureParsed(); if(!ok || !seq.events?.length){ log('No events to play'); return; } try{ await audioCtx.resume(); }catch(e){} const t0=audioCtx.currentTime; const startAt=t0 + (withGap? GAP_SEC : 0.06); try{ transport.gain.cancelScheduledValues(t0); transport.gain.setValueAtTime(0.0, t0); transport.gain.setTargetAtTime(1.0, startAt, 0.015); }catch(e){} for(let ch=0; ch<16; ch++){ const g=channels[ch].gain; if(g){ try{ g.gain.setValueAtTime(0.0, t0); g.gain.setTargetAtTime(channels[ch].baseGain*channels[ch].expr, startAt, 0.015); }catch(e){} } } updateMixGains(true); seq.startTime=startAt; seq.ptr=0; seq.running=true; if(seq.timer) clearInterval(seq.timer); seq.timer=setInterval(scheduleTick, seq.lookAhead*1000); log('‚ñ∂ '+(playlist[currentIndex]?.name||'')); lyrics.startAt = startAt; if(!audioOnly){ LyricsLive.rebuild(); LyricsLive.start(); Karo.rebuild(); Karo.start(lyrics.startAt); } }
  function stopPlayback(){ if(seq.timer) clearInterval(seq.timer); seq.timer=null; seq.running=false; try{ transport.gain.setTargetAtTime(0.0, audioCtx.currentTime, 0.02); }catch(e){} hardResetAudio(); log('‚èπ Stopped'); try{ LyricsLive && LyricsLive.stop(); }catch(_){} try{ Karo && Karo.stop(); }catch(_){} }
  function panicAll(){ hardResetAudio(); log('‚õë Panic: all voices killed and channels muted.'); try{ LyricsLive && LyricsLive.stop(); }catch(_){} try{ Karo && Karo.stop(); }catch(_){} }
  function scheduleTick(){ const horizon=audioCtx.currentTime - seq.startTime + seq.scheduleAhead; while(seq.ptr<seq.events.length){ const ev=seq.events[seq.ptr]; const when = seq.startTime + tickToSec(ev.tick - seq.startTick); if((when - audioCtx.currentTime) > seq.scheduleAhead) break; dispatchMidi(ev, when); seq.ptr++; } if(seq.ptr>=seq.events.length){ clearInterval(seq.timer); seq.timer=null; seq.running=false; log('‚úÖ Finished'); LyricsLive.stop(); Karo.stop(); if(contMode==='next'){ const next = currentIndex+1; if(next < playlist.length){ selectTrack(next); startPlayback(true); } } else if(contMode==='loop'){ selectTrack(currentIndex); startPlayback(true); } } }

  function anySolo(){ for(let ch=0; ch<16; ch++){ if(channels[ch].solo) return true; } return false; }
  function channelTargetFactor(ch){ const st=channels[ch]; const soloed=anySolo(); if(soloed){ return st.solo ? 1.0 : MUTE_FACTOR; } else { return st.mute ? MUTE_FACTOR : 1.0; } }
  function updateMixGains(hard=false){ if(!audioCtx) return; const now=audioCtx.currentTime; for(let ch=0; ch<16; ch++){ const st=channels[ch]; const g=st.gain?.gain; if(!g) continue; const base = st.baseGain * st.expr; const factor = channelTargetFactor(ch); const target = base * factor; try{ if(hard){ g.cancelScheduledValues(now); g.setValueAtTime(target, now); } else { g.setTargetAtTime(target, now, 0.03); } }catch(e){} } }

  const noteStartTimes = Array(16).fill(null).map(()=>new Map()); const stopRegistry   = Array(16).fill(null).map(()=>new Map());
  function gmToInst(prog, palette){ const p=prog|0; const cat=(p<=7)?'piano':(p<=15)?'chrom':(p<=23)?'organ':(p<=31)?'guitar':(p<=39)?'bass':(p<=47)?'strings':(p<=55)?'ens':(p<=63)?'brass':(p<=71)?'reed':(p<=79)?'pipe':(p<=87)?'lead':(p<=95)?'pad':(p<=103)?'fx':(p<=111)?'ethnic':(p<=119)?'perc':'sfx'; const mapClassic={ piano:'pianoLite', chrom:'fm', organ:'square', guitar:'guitar', bass:'deepBass', strings:'triangle', ens:'saw', brass:'square', reed:'triangle', pipe:'triangle', lead:'saw', pad:'square', fx:'fm', ethnic:'triangle', perc:'fm', sfx:'fm' }; const mapEDM={ piano:'pianoLite', chrom:'fm', organ:'square', guitar:'guitar', bass:'deepBass', strings:'saw', ens:'saw', brass:'square', reed:'triangle', pipe:'triangle', lead:'saw', pad:'saw', fx:'fm', ethnic:'triangle', perc:'fm', sfx:'fm' }; const mapChip={ piano:'pianoLite', chrom:'square', organ:'square', guitar:'guitar', bass:'deepBass', strings:'triangle', ens:'square', brass:'square', reed:'square', pipe:'square', lead:'square', pad:'square', fx:'square', ethnic:'square', perc:'square', sfx:'square' }; const table = palette==='edm'? mapEDM : palette==='chip'? mapChip : mapClassic; return table[cat] || 'triangle'; }
  function maybeAutoAssign(ch){ const st=channels[ch]; if(ch===9) return; if(!autoAssign) return; if(st.locked) return; const desired = (st.prog!=null) ? gmToInst(st.prog, palette) : chanFallbackInst(ch); if(st.inst==null || st.inst==='triangle' || st.inst==='saw' || st.inst==='square'){ st.inst = desired; } }

  function dispatchMidi(ev, when){ const ch=ev.ch||0; const st=channels[ch]; if(!st) return; const now=audioCtx?.currentTime || 0; switch(ev.type){ case 'noteOn':{ const note=ev.note|0; const vel=ev.vel|0; if(vel>0){ if(antiBeep && vel < 3) break; chAct[ch].level=Math.max(chAct[ch].level, vel/127); chAct[ch].last=now; chSeen[ch]=true; channels[ch].lastNote=midiToName(note); maybeAutoAssign(ch); titleBadges[ch].textContent=instSymbol(channels[ch].inst); noteStartTimes[ch].set(note, when); if(ch===9){ drumLiteVoice(ch, note, vel, when, st); } else { simpleVoiceDispatch(ch, note, vel, when); } } break; } case 'noteOff':{ const note=ev.note|0; const started=noteStartTimes[ch].get(note); if(started!=null){ const minMs=(ch===9?MIN_NOTE_MS_DRUMS:MIN_NOTE_MS_MELODY); const minDur=minMs/1000; const plannedStop=Math.max(when, started+minDur); scheduleStop(ch, note, plannedStop); noteStartTimes[ch].delete(note); } break; } case 'cc':{ const cc=ev.cc|0, val=ev.value|0; chAct[ch].last=now; chSeen[ch]=true; if(cc===7){ st.baseGain=val/127; updateMixGains(); } else if(cc===10){ const pan=(val-64)/64; if(!st.pan && audioCtx.createStereoPanner){ st.pan=audioCtx.createStereoPanner(); st.pan.pan.value=0; st.pan.connect(st.gain||masterIn); } if(st.pan) st.pan.pan.value=Math.max(-1,Math.min(1,pan)); } else if(cc===11){ st.expr=val/127; updateMixGains(); } break; } case 'program':{ st.prog=ev.prog|0; chAct[ch].last=now; chSeen[ch]=true; maybeAutoAssign(ch); titleBadges[ch].textContent=instSymbol(channels[ch].inst); break; } case 'pitchbend':{ const bend=(((ev.msb|0)<<7)|(ev.lsb|0))-8192; st.bend=(bend/8192)*2; chAct[ch].last=now; chSeen[ch]=true; break; } } }
  function scheduleStop(ch, note, tStop){ const reg=stopRegistry[ch].get(note); if(reg && reg.stop){ try{ reg.stop(tStop); }catch(e){} stopRegistry[ch].delete(note); } }

  function simpleVoiceDispatch(ch, note, vel, when){ const st=channels[ch]; const inst=st.inst || (useTriangle?'triangle':'saw'); if(inst==='pianoLite') return pianoLiteVoice(ch, note, vel, when); if(inst==='deepBass') return deepBassVoice(ch, note, vel, when); if(inst==='guitar') return guitarLiteVoice(ch, note, vel, when); return simpleVoice(ch, note, vel, when); }
  function midiToName(m){ const names=['C','C#','D','D#','E','F','F#','G','G#','A','A#','B']; const n=names[m%12]; const o=Math.floor(m/12)-1; return n+o; }
  function trackVoice(node, stopAt, ch, gain){ voices.push({node, stopAt, ch, gain}); }

  function simpleVoice(ch, note, vel, when){ const st=channels[ch]; const v=Math.max(1,vel)/127; let f=midiToFreq(note)*Math.pow(2,(st.bend||0)/12); f *= globalDetuneRatio; const inst=st.inst || (useTriangle?'triangle':'saw'); let o=audioCtx.createOscillator(); let amp=audioCtx.createGain(); const g=amp.gain; o.type=(inst==='triangle'||inst==='triangle_soft')? 'triangle' : (inst==='square'? 'square':'sawtooth'); o.frequency.value=f; const bp=audioCtx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=1200+900*v; bp.Q.value=0.8; const dc=audioCtx.createBiquadFilter(); dc.type='highpass'; dc.frequency.value=12; dc.Q.value=0.707; g.cancelScheduledValues(when); g.setValueAtTime(0.00012, when); g.linearRampToValueAtTime(v, when+ENV_ATTACK); const dest = st.pan? st.pan : (st.gain||masterIn); o.connect(bp).connect(dc); dc.connect(amp); amp.connect(dest); o.start(when); const plannedStop=when+ENV_RELEASE+0.80; stopRegistry[ch].set(note,{ stop:(tStop)=>{ try{ g.cancelScheduledValues(tStop); g.setValueAtTime(g.value, tStop); g.linearRampToValueAtTime(0.00012, tStop+ENV_RELEASE); o.stop(Math.max(tStop+ENV_RELEASE+0.02, when+ENV_RELEASE+0.02));}catch(e){} } }); trackVoice(o, plannedStop, ch, g); }

  function pianoLiteVoice(ch, note, vel, when){ const st=channels[ch]; const v=Math.max(1,vel)/127; let f=midiToFreq(note)*Math.pow(2,(st.bend||0)/12); f *= globalDetuneRatio; const mix = audioCtx.createGain(); const g = mix.gain; g.setValueAtTime(0.00012, when); g.linearRampToValueAtTime(v, when+0.008); g.linearRampToValueAtTime(v*0.62, when+0.130); const lp = audioCtx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.setValueAtTime(1500 + 2800*v, when); lp.frequency.linearRampToValueAtTime(1100 + 1200*v, when+0.300); lp.Q.value = 0.8; const o1 = audioCtx.createOscillator(); o1.type='triangle'; o1.frequency.value=f; const o2 = audioCtx.createOscillator(); o2.type='sine'; o2.frequency.value=f * Math.pow(2, +3/1200); const o3 = audioCtx.createOscillator(); o3.type='sine'; o3.frequency.value=f * Math.pow(2, -3/1200); const o4 = audioCtx.createOscillator(); o4.type='sine'; o4.frequency.value=f*2; const g1 = audioCtx.createGain(); g1.gain.value = 0.70; const g2 = audioCtx.createGain(); g2.gain.value = 0.22; const g3 = audioCtx.createGain(); g3.gain.value = 0.22; const g4 = audioCtx.createGain(); g4.gain.value = 0.12; const dc = audioCtx.createBiquadFilter(); dc.type='highpass'; dc.frequency.value=12; dc.Q.value=0.707; o1.connect(g1).connect(lp).connect(dc).connect(mix); o2.connect(g2).connect(lp).connect(dc).connect(mix); o3.connect(g3).connect(lp).connect(dc).connect(mix); o4.connect(g4).connect(lp).connect(dc).connect(mix); const ns = audioCtx.createBufferSource(); const sr=audioCtx.sampleRate; const nlen=Math.floor(sr*0.010); const nbuf=audioCtx.createBuffer(1,nlen,sr); const nd=nbuf.getChannelData(0); for(let i=0;i<nlen;i++){ nd[i]=(Math.random()*2-1); } const nh = audioCtx.createBiquadFilter(); nh.type='highpass'; nh.frequency.value=2500 + 2000*v; const ng = audioCtx.createGain(); ng.gain.setValueAtTime(0.00012, when); ng.gain.linearRampToValueAtTime(0.18*v, when+0.004); ng.gain.exponentialRampToValueAtTime(0.00012, when+0.030); ns.buffer=nbuf; ns.connect(nh).connect(ng).connect(lp).connect(dc).connect(mix); const dest = st.pan? st.pan : (st.gain||masterIn); mix.connect(dest); o1.start(when); o2.start(when); o3.start(when); o4.start(when); ns.start(when); const stopFn = (tStop)=>{ try{ g.cancelScheduledValues(tStop); g.setValueAtTime(g.value, tStop); g.linearRampToValueAtTime(0.00012, tStop + 0.400); o1.stop(Math.max(tStop + 0.420, when + 0.420)); o2.stop(Math.max(tStop + 0.420, when + 0.420)); o3.stop(Math.max(tStop + 0.420, when + 0.420)); o4.stop(Math.max(tStop + 0.420, when + 0.420)); ns.stop(Math.max(tStop + 0.050, when + 0.050)); }catch(e){} }; stopRegistry[ch].set(note,{ stop: stopFn }); trackVoice(o1, when+1.2, ch, g); trackVoice(o2, when+1.2, ch, g); trackVoice(o3, when+1.2, ch, g); trackVoice(o4, when+1.2, ch, g); trackVoice(ns, when+0.10, ch, ng.gain); }

  function deepBassVoice(ch, note, vel, when){ const st=channels[ch]; const v=Math.max(1,vel)/127; let f=midiToFreq(note)*Math.pow(2,(st.bend||0)/12); f *= globalDetuneRatio; const mix = audioCtx.createGain(); const g = mix.gain; g.setValueAtTime(0.00012, when); g.linearRampToValueAtTime(v*0.95, when+0.006); g.linearRampToValueAtTime(v*0.75, when+0.120); const lp = audioCtx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.setValueAtTime(400 + 900*v, when); lp.Q.value = 0.7; const oBody = audioCtx.createOscillator(); oBody.type='triangle'; oBody.frequency.value=f; const oSub  = audioCtx.createOscillator(); oSub.type='sine'; oSub.frequency.value=f/2; const gBody = audioCtx.createGain(); gBody.gain.value = 0.65; const gSub  = audioCtx.createGain(); gSub.gain.value  = 0.85; const drive = audioCtx.createWaveShaper(); drive.curve = makeSoftClipCurve(0.82); drive.oversample = '4x'; const dc = audioCtx.createBiquadFilter(); dc.type='highpass'; dc.frequency.value=12; dc.Q.value=0.707; const ns = audioCtx.createBufferSource(); const sr=audioCtx.sampleRate; const nlen=Math.floor(sr*0.006); const nbuf=audioCtx.createBuffer(1,nlen,sr); const nd=nbuf.getChannelData(0); for(let i=0;i<nlen;i++){ nd[i]=(Math.random()*2-1); } const nHP = audioCtx.createBiquadFilter(); nHP.type='highpass'; nHP.frequency.value=1200; const nG  = audioCtx.createGain(); nG.gain.setValueAtTime(0.00012, when); nG.gain.linearRampToValueAtTime(0.12*v, when+0.002); nG.gain.exponentialRampToValueAtTime(0.00012, when+0.030); ns.buffer=nbuf; oBody.connect(gBody).connect(lp); oSub .connect(gSub ).connect(lp); ns.connect(nHP).connect(nG).connect(lp); lp.connect(drive).connect(dc).connect(mix); const dest = st.pan? st.pan : (st.gain||masterIn); mix.connect(dest); oBody.start(when); oSub.start(when); ns.start(when); const stopFn = (tStop)=>{ try{ g.cancelScheduledValues(tStop); g.setValueAtTime(g.value, tStop); g.linearRampToValueAtTime(0.00012, tStop + 0.180); oBody.stop(Math.max(tStop + 0.200, when + 0.200)); oSub.stop(Math.max(tStop + 0.200, when + 0.200)); ns.stop(Math.max(tStop + 0.040, when + 0.040)); }catch(e){} }; stopRegistry[ch].set(note,{ stop: stopFn }); trackVoice(oBody, when+0.90, ch, g); trackVoice(oSub, when+0.90, ch, g); trackVoice(ns, when+0.06, ch, nG.gain); }

  function guitarLiteVoice(ch, note, vel, when){ const st=channels[ch]; const v=Math.max(1,vel)/127; let f=midiToFreq(note)*Math.pow(2,(st.bend||0)/12); f *= globalDetuneRatio; const mix = audioCtx.createGain(); const g = mix.gain; g.setValueAtTime(0.00012, when); g.linearRampToValueAtTime(v*0.95, when+0.005); g.linearRampToValueAtTime(v*0.42, when+0.140); const bp = audioCtx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=1400; bp.Q.value=1.0; const lp = audioCtx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=2600; lp.Q.value=0.7; const dc = audioCtx.createBiquadFilter(); dc.type='highpass'; dc.frequency.value=12; dc.Q.value=0.707; const o1 = audioCtx.createOscillator(); o1.type='triangle'; o1.frequency.value=f * Math.pow(2, +3/1200); const o2 = audioCtx.createOscillator(); o2.type='sawtooth'; o2.frequency.value=f * Math.pow(2, -3/1200); try{ o1.frequency.linearRampToValueAtTime(o1.frequency.value*0.997, when+0.080); }catch(e){} try{ o2.frequency.linearRampToValueAtTime(o2.frequency.value*0.997, when+0.080); }catch(e){} const ns = audioCtx.createBufferSource(); const sr=audioCtx.sampleRate; const nlen=Math.floor(sr*0.010); const nbuf=audioCtx.createBuffer(1,nlen,sr); const nd=nbuf.getChannelData(0); for(let i=0;i<nlen;i++){ nd[i]=(Math.random()*2-1); } const nHP = audioCtx.createBiquadFilter(); nHP.type='highpass'; nHP.frequency.value=2200; const nG  = audioCtx.createGain(); nG.gain.setValueAtTime(0.00012, when); nG.gain.linearRampToValueAtTime(0.18*v, when+0.003); nG.gain.exponentialRampToValueAtTime(0.00012, when+0.035); ns.buffer=nbuf; o1.connect(bp).connect(lp).connect(dc).connect(mix); o2.connect(bp).connect(lp).connect(dc).connect(mix); ns.connect(nHP).connect(nG).connect(bp); const dest = st.pan? st.pan : (st.gain||masterIn); mix.connect(dest); o1.start(when); o2.start(when); ns.start(when); const stopFn = (tStop)=>{ try{ g.cancelScheduledValues(tStop); g.setValueAtTime(g.value, tStop); g.linearRampToValueAtTime(0.00012, tStop + 0.280); o1.stop(Math.max(tStop + 0.300, when + 0.300)); o2.stop(Math.max(tStop + 0.300, when + 0.300)); ns.stop(Math.max(tStop + 0.050, when + 0.050)); }catch(e){} }; stopRegistry[ch].set(note,{ stop: stopFn }); trackVoice(o1, when+0.90, ch, g); trackVoice(o2, when+0.90, ch, g); trackVoice(ns, when+0.06, ch, nG.gain); }

  function drumLiteVoice(ch, note, vel, when, st){ const v=Math.max(1,vel)/127; const minDur=MIN_NOTE_MS_DRUMS/1000; if(note===35||note===36){ const osc=audioCtx.createOscillator(); osc.type='sine'; const g=audioCtx.createGain(); g.gain.setValueAtTime(0.00012, when); g.gain.linearRampToValueAtTime(0.95*v, when+0.006); g.gain.exponentialRampToValueAtTime(0.00012, when+0.18); osc.frequency.setValueAtTime(95, when); osc.frequency.exponentialRampToValueAtTime(50, when+0.08); const dest=st.gain||masterIn; osc.connect(g).connect(dest); osc.start(when); const stopAt=when+0.20; stopRegistry[ch].set(note,{ stop:(t)=>{ try{ osc.stop(Math.max(stopAt, t)); }catch(e){} } }); trackVoice(osc, stopAt, ch, g.gain); return; } if(note===38||note===40){ const sr=audioCtx.sampleRate; const len=Math.floor(sr*0.26); const buf=audioCtx.createBuffer(1,len,sr); const d=buf.getChannelData(0); for(let i=0;i<len;i++){ const r=Math.random()*2-1; d[i]=(i>0? d[i-1]*0.20 + r*0.80 : r); } const noise=audioCtx.createBufferSource(); noise.buffer=buf; const bp=audioCtx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=220; bp.Q.value=0.8; const hp=audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=3000; const g=audioCtx.createGain(); g.gain.setValueAtTime(0.9*v, when); g.gain.exponentialRampToValueAtTime(0.00012, when+0.26); const dest=st.gain||masterIn; noise.connect(bp).connect(hp).connect(g).connect(dest); noise.start(when); const stopAt=when+0.28; stopRegistry[ch].set(note,{ stop:(t)=>{ try{ noise.stop(Math.max(stopAt, t)); }catch(e){} } }); trackVoice(noise, stopAt, ch, g.gain); return; } if(note===42||note===46){ const dur=(note===46? Math.max(minDur,0.32) : Math.max(minDur,0.16)); const sr=audioCtx.sampleRate; const len=Math.floor(sr*dur); const buf=audioCtx.createBuffer(1,len,sr); const d=buf.getChannelData(0); for(let i=0;i<len;i++){ const r=Math.random()*2-1; d[i]=(i>0? d[i-1]*0.12 + r*0.88 : r); } const noise=audioCtx.createBufferSource(); noise.buffer=buf; const hp=audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=7000; const g=audioCtx.createGain(); g.gain.setValueAtTime(0.7*v, when); g.gain.exponentialRampToValueAtTime(0.00012, when+dur); const dest=st.gain||masterIn; noise.connect(hp).connect(g).connect(dest); noise.start(when); const stopAt=when+dur+0.02; stopRegistry[ch].set(note,{ stop:(t)=>{ try{ noise.stop(Math.max(stopAt, t)); }catch(e){} } }); trackVoice(noise, stopAt, ch, g.gain); return; } if(note===49||note===51){ const dur=(note===49? 1.5 : 1.1); const sr=audioCtx.sampleRate; const len=Math.floor(sr*dur); const buf=audioCtx.createBuffer(1,len,sr); const d=buf.getChannelData(0); for(let i=0;i<len;i++){ const r=Math.random()*2-1; d[i]=(i>0? d[i-1]*0.10 + r*0.90 : r); } const noise=audioCtx.createBufferSource(); noise.buffer=buf; const hp=audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=5000; const g=audioCtx.createGain(); g.gain.setValueAtTime(0.65*v, when); g.gain.exponentialRampToValueAtTime(0.00012, when+dur); const dest=st.gain||masterIn; noise.connect(hp).connect(g).connect(dest); noise.start(when); const stopAt=when+dur+0.02; stopRegistry[ch].set(note,{ stop:(t)=>{ try{ noise.stop(Math.max(stopAt, t)); }catch(e){} } }); trackVoice(noise, stopAt, ch, g.gain); return; } const osc=audioCtx.createOscillator(); osc.type='sine'; const g=audioCtx.createGain(); g.gain.setValueAtTime(0.00012, when); g.gain.linearRampToValueAtTime(0.4*v, when+0.004); g.gain.exponentialRampToValueAtTime(0.00012, when+minDur); const dest=st.gain||masterIn; osc.frequency.value=800; osc.connect(g).connect(dest); osc.start(when); const stopAt=when+minDur+0.02; stopRegistry[ch].set(note,{ stop:(t)=>{ try{ osc.stop(Math.max(stopAt, t)); }catch(e){} } }); trackVoice(osc, stopAt, ch, g.gain); }

  function voiceWatchdogLoop(){ if(!audioCtx){ requestAnimationFrame(voiceWatchdogLoop); return; } const now = audioCtx.currentTime; for(let i=voices.length-1; i>=0; i--){ const v=voices[i]; if(now > (v.stopAt + 0.25)){ try{ v.gain && v.gain.cancelScheduledValues(now); v.gain && v.gain.setValueAtTime(0.00012, now); v.node.stop?.(now+0.01); v.node.disconnect?.(); }catch(e){} voices.splice(i,1); } } for(let ch=0; ch<16; ch++){ const act=chAct[ch]; const inst=channels[ch].inst || (ch===9?'drumLite':'triangle'); const conf=FAILSAFE_TABLE[inst] || {lvl:0.30, idle:1.8}; const stale=(now - (act.last||0))>conf.idle; const high=act.level>conf.lvl; if(high && stale){ try{ channels[ch].gain.gain.setTargetAtTime(0.0, now, 0.03); }catch(e){} for(let i=voices.length-1;i>=0;i--){ const v=voices[i]; if(v.ch===ch){ try{ v.node.stop?.(now+0.01); v.node.disconnect?.(); }catch(e){} voices.splice(i,1); } } log(`Failsafe: CH${ch+1} (${inst}) abnormal ‚Äî muted & culled.`); act.level=0; act.last=now; if(autoRecovery){ const back=channels[ch].baseGain*channels[ch].expr*channelTargetFactor(ch); try{ channels[ch].gain.gain.setTargetAtTime(back, now+1.2, 0.08); }catch(e){} log(`Auto‚Äërecovery: CH${ch+1} ~1.2s.`); } } } requestAnimationFrame(voiceWatchdogLoop); }
  function chRenderLoop(){ const DECAY=0.92; for(let ch=0; ch<16; ch++){ const a=chAct[ch]; a.level *= DECAY; if(a.level<0.01) a.level=0; } updateMixerMeters(); requestAnimationFrame(chRenderLoop); }
  function hardResetAudio(){ if(!audioCtx) return; const t=audioCtx.currentTime; for(let ch=0; ch<16; ch++){ for(const [note, reg] of stopRegistry[ch].entries()){ try{ reg.stop?.(t); }catch(e){} } stopRegistry[ch].clear(); noteStartTimes[ch].clear(); } for(let i=voices.length-1; i>=0; i--){ const v=voices[i]; try{ v.node.stop?.(t+0.01); v.node.disconnect?.(); }catch(e){} voices.splice(i,1); } try{ transport.gain.cancelScheduledValues(t); transport.gain.setValueAtTime(0.0, t); }catch(e){} for(let ch=0; ch<16; ch++){ const g=channels[ch].gain; if(g){ try{ g.gain.cancelScheduledValues(t); g.gain.setValueAtTime(0.0, t); }catch(e){} } } for (let ch=0; ch<16; ch++){ chAct[ch].level=0; chAct[ch].last=t; } updateMixerMeters(); stopSolfOscs(); }

  function makeSoftClipCurve(k=0.78){ const n=2048, curve=new Float32Array(n); for(let i=0;i<n;i++){ const x=(i/(n-1))*2-1; curve[i]=Math.tanh(k*x); } return curve; }
  function readBE32(u8,o){ return (u8[o]<<24)|(u8[o+1]<<16)|(u8[o+2]<<8)|u8[o+3]; }
  function readVLQ(u8,o){ let v=0,b=0; while(true){ const c=u8[o+b++]; v=(v<<7)|(c&0x7F); if((c&0x80)===0) break; } return {value:v,bytes:b}; }
  function parseSMF(bytes){ if(String.fromCharCode(bytes[0],bytes[1],bytes[2],bytes[3])!=='MThd') throw new Error('Missing MThd'); const hLen=readBE32(bytes,4); const format=(bytes[8]<<8)|bytes[9]; const nTracks=(bytes[10]<<8)|bytes[11]; const division=(bytes[12]<<8)|bytes[13]; let pos=8+hLen; const tracks=[]; for(let ti=0; ti<nTracks; ti++){ if(String.fromCharCode(bytes[pos],bytes[pos+1],bytes[pos+2],bytes[pos+3])!=='MTrk') throw new Error('Track '+ti+': missing MTrk'); const tLen=readBE32(bytes,pos+4); const dStart=pos+8; const dEnd=dStart+tLen; tracks.push({dStart,dEnd}); pos=dEnd; } return {format,nTracks,division,tracks,bytes}; }
  function buildTempoMap(smf){ const tpq=smf.division; const tempos=[]; for(const tr of smf.tracks){ let p=tr.dStart, tick=0, run=null; while(p<tr.dEnd){ const d=readVLQ(smf.bytes,p); p+=d.bytes; tick+=d.value; let st=smf.bytes[p++]; if(st<0x80){ if(run===null) throw new Error('Running status without previous'); p--; st=run; } else { run=st; } if(st===0xFF){ const type=smf.bytes[p++]; const ln=readVLQ(smf.bytes,p); p+=ln.bytes; const ds=p, de=p+ln.value; if(type===0x51 && ln.value===3){ const a=smf.bytes[ds], b=smf.bytes[ds+1], c=smf.bytes[ds+2]; const usPerQN=(a<<16)|(b<<8)|c; tempos.push({tick, usPerQN}); } p=de; } else if((st&0xF0)===0xF0){ const ln2=readVLQ(smf.bytes,p); p+=ln2.bytes+ln2.value; } else { if((st&0xF0)!==0xC0 && (st&0xF0)!==0xD0) p++; p++; } } } if(tempos.length===0 || tempos[0].tick>0) tempos.unshift({tick:0, usPerQN:500000}); tempos.sort((a,b)=>a.tick-b.tick); const tickToSec=(tick)=>{ let sec=0, prev=0; for(let i=0;i<tempos.length;i++){ const cur=tempos[i]; const next=tempos[i+1]?.tick ?? tick; const end=Math.min(next, tick); if(end<=prev) break; const dt=end-prev; sec += (dt * (cur.usPerQN/1e6)) / tpq; prev=end; if(end===tick) break; } return sec; }; return {tpq, tempos, tickToSec}; }
  function collectEvents(smf){ const out=[]; for(const tr of smf.tracks){ let p=tr.dStart, tick=0, run=null; while(p<tr.dEnd){ const d=readVLQ(smf.bytes,p); p+=d.bytes; tick+=d.value; let st=smf.bytes[p++]; if(st<0x80){ if(run===null) throw new Error('Running status without previous'); p--; st=run; } else { run=st; } if(st===0xFF){ const type=smf.bytes[p++]; const ln=readVLQ(smf.bytes,p); p+=ln.bytes; const ds=p, de=p+ln.value; p=de; run=null; } else if((st&0xF0)===0xF0){ const ln2=readVLQ(smf.bytes,p); p+=ln2.bytes+ln2.value; run=null; } else { const ch=st&0x0F; const T=(st&0xF0); let d1=smf.bytes[p++]; let d2=null; if(T!==0xC0 && T!==0xD0){ d2=smf.bytes[p++]; } if(T===0x90){ const vel=d2|0; if(vel>0) out.push({type:'noteOn', tick, ch, note:d1|0, vel}); else out.push({type:'noteOff', tick, ch, note:d1|0}); } else if(T===0x80){ out.push({type:'noteOff', tick, ch, note:d1|0}); } else if(T===0xB0){ out.push({type:'cc', tick, ch, cc:d1|0, value:(d2||0)|0}); } else if(T===0xC0){ out.push({type:'program', tick, ch, prog:d1|0}); } else if(T===0xE0){ const v=((d2|0)<<7)|(d1|0); out.push({type:'pitchbend', tick, ch, lsb:v&0x7F, msb:(v>>7)&0x7F}); } } } } out.sort((a,b)=>a.tick-b.tick); return out; }
  function collectMetaLyrics(smf){ const meta=[]; for(const tr of smf.tracks){ let p=tr.dStart, tick=0, run=null; while(p<tr.dEnd){ const d=readVLQ(smf.bytes,p); p+=d.bytes; tick+=d.value; let st=smf.bytes[p++]; if(st<0x80){ if(run===null) throw new Error('Running status without previous'); p--; st=run; } else { run=st; } if(st===0xFF){ const type=smf.bytes[p++]; const ln=readVLQ(smf.bytes,p); p+=ln.bytes; const ds=p, de=p+ln.value; if(type===0x05 || type===0x01 || type===0x03){ meta.push({kind:'meta', tick, type, data: smf.bytes.slice(ds,de)}); } p=de; run=null; } else if((st&0xF0)===0xF0){ const ln2=readVLQ(smf.bytes,p); p+=ln2.bytes+ln2.value; run=null; } else { const T=(st&0xF0); if(T!==0xC0 && T!==0xD0) p++; p++; } } } meta.sort((a,b)=>a.tick-b.tick); return meta; }
  (function(){ let decLatin1=null, decUtf8=null; try{ decLatin1=new TextDecoder('latin1'); }catch(_){} try{ decUtf8=new TextDecoder('utf-8'); }catch(_){} function decodeText(bytes, enc){ if(enc==='utf8' && decUtf8){ try{ return decUtf8.decode(bytes); }catch(_){} } if(decLatin1){ try{ return decLatin1.decode(bytes); }catch(_){} } let s=''; for(let i=0;i<bytes.length;i++) s+=String.fromCharCode(bytes[i]); return s; } window.buildLyricsJSON=function(metaEvs, tickToSec, allowTypes, opts){ const allow = new Set(allowTypes && allowTypes.length ? allowTypes : [0x05]); const preserveSpaces=!!(opts&&opts.preserveSpaces); const splitOnSlash=(opts&&'splitOnSlash' in opts)? !!opts.splitOnSlash : true; const enc=(opts&&opts.enc)||'latin1'; const lines=[]; let cur=null; function pushWord(tSec,w){ if(!cur) cur={ main_time:tSec, text:'', words:[] }; if(w===''&& !preserveSpaces) return; cur.words.push({ t:tSec, w }); } function finalize(){ if(cur && cur.words.length){ let txt=''; for(let i=0;i<cur.words.length;i++) txt+=cur.words[i].w; cur.text=txt; lines.push(cur); } cur=null; } for(const e of metaEvs){ if(e.kind!=='meta' || !allow.has(e.type)) continue; const sec=tickToSec(e.tick); if(sec<=1e-9) continue; let payload=decodeText(e.data,enc)||''; payload=payload.replace(/\u0000/g,''); const probe=payload.replace(/\r\n?/g,'\n').trim(); if(/^@/.test(probe) || /^TITLE\s*:/.test(probe) || /^ARTIST\s*:/.test(probe) || /^LANGUAGE\s*:/.test(probe) || /^KMIDI\s+KARAOKE\s+FILE$/i.test(probe)) continue; if(!payload.length){ finalize(); continue; } payload=payload.replace(/\uFF0F/g,'/').replace(/\uFF3C/g,'\\'); for(let j=0;j<payload.length;j++){ const ch=payload[j]; if(ch==='\\'){ const nx=(j+1<payload.length)? payload[j+1]:''; if(nx===' ' && preserveSpaces){ pushWord(sec,' '); j++; } else if(nx==='/'||nx==='\\'){ j++; } finalize(); continue; } if(ch==='\n'||ch==='\r'){ finalize(); continue; } if(splitOnSlash && ch=== '/'){ finalize(); continue; } if(ch===' '){ if(preserveSpaces) pushWord(sec,' '); continue; } let k=j, buf=ch; while(k+1<payload.length){ const nx2=payload[k+1]; if(nx2==='\\') break; if(nx2==='\n'||nx2==='\r'||(splitOnSlash && nx2=='/')||nx2===' ') break; buf+=nx2; k++; } j=k; pushWord(sec,buf); } } finalize();return { lines }; }; })();

  function prepareLyLines(json){ const arr=[]; const lines=Array.isArray(json?.lines)? json.lines:[]; for(let i=0;i<lines.length;i++){ const ln=lines[i]||{}, words=Array.isArray(ln.words)? ln.words:[]; const main=(ln.main_time!=null)? ln.main_time : (words[0]? (words[0].t||0):0); const end=(i+1<lines.length && lines[i+1].main_time!=null)? lines[i+1].main_time : (words.length? (words[words.length-1].t||main):main); arr.push({ idx:i, main, end, words, text:(ln.text||'') }); } return arr; }
  function renderLyricsStatic(){ const full=document.getElementById('lyFull'); const toks=document.getElementById('lyTokens'); const prev=document.getElementById('lyPrev'); const curr=document.getElementById('lyCurr'); const next=document.getElementById('lyNext'); const lines=prepareLyLines(lyrics.json); if(full){ full.innerHTML=''; for(const L of lines){ const div=document.createElement('div'); div.style.margin='3px 0'; div.textContent = `[${(L.main||0).toFixed(2)}] ${L.text||''}`; full.appendChild(div); } } if(toks){ toks.innerHTML=''; for(const L of lines){ const head=document.createElement('div'); head.style.color='#9fbad1'; head.textContent=`[${(L.main||0).toFixed(2)}]`; toks.appendChild(head); for(const w of L.words){ const row=document.createElement('div'); const tm=document.createElement('span'); tm.style.marginRight='8px'; tm.textContent=`[${(w.t||0).toFixed(2)}]`; const tx=document.createElement('span'); tx.textContent=(w.w===' ')? '‚ê†' : String(w.w||''); row.appendChild(tm); row.appendChild(tx); toks.appendChild(row); } } } if(prev) prev.textContent=''; if(curr) curr.textContent=''; if(next) next.textContent=''; }
  (function(){ let linesPrepared=[], curIndex=-1; function drawNow(nowRel){ const prev=document.getElementById('lyPrev'); const curr=document.getElementById('lyCurr'); const next=document.getElementById('lyNext'); if(!curr || !next) return; let li=curIndex; if(li<0 || !(linesPrepared[li] && linesPrepared[li].main<=nowRel && nowRel<linesPrepared[li].end)){ while(li+1<linesPrepared.length && linesPrepared[li+1].main<=nowRel) li++; while(li>0 && linesPrepared[li].main>nowRel) li--; curIndex=Math.max(0,li); } const P=(curIndex>0? linesPrepared[curIndex-1]:null); const C=(linesPrepared[curIndex]||null); const N=(curIndex+1<linesPrepared.length? linesPrepared[curIndex+1]:null); if(prev) prev.textContent = P? (P.text||'') : ''; curr.innerHTML=''; if(C){ let ti=-1; for(let i=0;i<C.words.length;i++){ if((C.words[i].t||0)<=nowRel) ti=i; else break; } for(let i=0;i<C.words.length;i++){ const sp=document.createElement('span'); sp.className='lyTok'; if(i<ti) sp.classList.add('done'); else if(i===ti) sp.classList.add('active'); sp.textContent=(C.words[i].w===' ')? ' ' : String(C.words[i].w||''); curr.appendChild(sp); } } if(next) next.textContent = N? (N.text||'') : ''; }
    function loop(){ const nowRel=(audioCtx? audioCtx.currentTime:0) - (lyrics.startAt||0); drawNow(nowRel); lyrics.raf=requestAnimationFrame(loop); }
    window.LyricsLive = { rebuild(){ linesPrepared=prepareLyLines(lyrics.json); curIndex=-1; drawNow(0); }, start(){ cancelAnimationFrame(lyrics.raf||0); lyrics.raf=requestAnimationFrame(loop); }, stop(){ cancelAnimationFrame(lyrics.raf||0); lyrics.raf=0; } };
  })();

  // === APPEND: Non-invasive Lyrics countdown (chip + live updater) ===
  (function(){
    const CHIP_ID = 'lyCountdown';
    let cRAF = 0;

    function ensureCountdownChip(){
      if(document.getElementById(CHIP_ID)) return;
      const win = document.getElementById('winLyrics');
      if(!win) return;
      const body = win.querySelector('.winBody');
      if(!body) return;
      const chip = document.createElement('span');
      chip.id = CHIP_ID;
      chip.className = 'chip';
      chip.title = 'Seconds until next lyric line starts';
      chip.style.marginBottom = '8px';
      chip.style.display = 'inline-block';
      chip.textContent = '‚è± Next in: --';
      const anchor = document.getElementById('lyPrev');
      if(anchor && anchor.parentNode){
        anchor.parentNode.insertBefore(chip, anchor);
      } else {
        body.insertBefore(chip, body.firstChild);
      }
    }

    function updateCountdown(nowRel){
      const chip = document.getElementById(CHIP_ID);
      if(!chip) return;
      const lines = (function(){
        try{ return prepareLyLines(lyrics.json); }catch(_){ return []; }
      })();
      if(!lines.length){ chip.textContent = '‚è± Next in: --'; chip.style.color = '#9fbad1'; chip.style.display=''; return; }
      let li = 0;
      while(li+1 < lines.length && lines[li+1].main <= nowRel) li++;
      const nextMain = (li+1 < lines.length) ? (lines[li+1].main || NaN) : NaN;
      const delta = (isFinite(nextMain) ? nextMain - nowRel : NaN);
      if(!isFinite(delta) || delta < 0){
        chip.textContent = '‚è± Next in: --';
        chip.style.color = '#9fbad1';
        return;
      }
      chip.textContent = '‚è± Next in: ' + delta.toFixed(2) + 's';
      chip.style.color = (delta < 0.20) ? '#f31260' : (delta < 0.50 ? '#f5a524' : '#9fbad1');
    }

    const origRebuild = window.LyricsLive && window.LyricsLive.rebuild;
    const origStart   = window.LyricsLive && window.LyricsLive.start;
    const origStop    = window.LyricsLive && window.LyricsLive.stop;
    if(window.LyricsLive){
      window.LyricsLive.rebuild = function(){
        try{ ensureCountdownChip(); updateCountdown(0); }catch(_){}
        if(origRebuild) origRebuild.call(window.LyricsLive);
      };
      window.LyricsLive.start = function(){
        if(origStart) origStart.call(window.LyricsLive);
        try{ ensureCountdownChip(); }catch(_){}
        cancelAnimationFrame(cRAF||0);
        const loop = ()=>{
          const nowRel=(audioCtx? audioCtx.currentTime:0) - (lyrics.startAt||0);
          try{ updateCountdown(nowRel); }catch(_){ }
          cRAF = requestAnimationFrame(loop);
        };
        cRAF = requestAnimationFrame(loop);
      };
      window.LyricsLive.stop = function(){
        cancelAnimationFrame(cRAF||0); cRAF = 0;
        if(origStop) origStop.call(window.LyricsLive);
      };
    }
  })();
  (function(){ const EPS=0.0015; function caseTransformText(s){ const v=KaroState.case||'none'; if(v==='upper') return String(s||'').toUpperCase(); if(v==='lower') return String(s||'').toLowerCase(); if(v==='cap') return String(s||'').replace(/\b([A-Za-z])/g,(m)=>m.toUpperCase()); if(v==='sentence'){ const lower=String(s||'').toLowerCase(); const idx=lower.search(/[a-z]/i); if(idx<0) return lower; return lower.slice(0,idx)+lower[idx].toUpperCase()+lower.slice(idx+1); } return s||''; } function prepareLines(json){ const out=[]; const lines=Array.isArray(json?.lines)? json.lines:[]; for(let i=0;i<lines.length;i++){ const ln=lines[i]||{}, words=Array.isArray(ln.words)? ln.words:[]; const main=(ln.main_time!=null)? ln.main_time : (words[0]? (words[0].t||0):0); const end=(i+1<lines.length && lines[i+1].main_time!=null)? lines[i+1].main_time : (words.length? (words[words.length-1].t||main):main); out.push({ idx:i, main, end, words, text:(ln.text||'') }); } return out; } function computeActiveGroup(toks, now){ let ai=-1; for(let i=0;i<toks.length;i++){ if((toks[i].t||0)<=now) ai=i; else break; } if(ai<0) return {ai:-1,L:-1,R:-1,at:0}; const at=toks[ai].t||0; let L=ai,R=ai; while(L-1>=0 && Math.abs((toks[L-1].t||0)-at)<=EPS){ L--; } while(R+1<toks.length && Math.abs((toks[R+1].t||0)-at)<=EPS){ R++; } return {ai,L,R,at}; } function letterSpan(ch, progressPct){ const wrap=document.createElement('span'); wrap.className='karoChar'; const base=document.createElement('span'); base.className='karoLetter base'; base.textContent=(ch===' ')? '\u00A0':ch; const hi=document.createElement('span'); hi.className='karoLetter hi'; hi.textContent=(ch===' ')? '\u00A0':ch; wrap.style.setProperty('--kara-progress', Math.max(0,Math.min(100,progressPct))+'%'); wrap.appendChild(base); wrap.appendChild(hi); return wrap; } function pushWordLetters(tspan, word, progress){ const len=word.length||1; const filled=Math.max(0,Math.min(1,progress))*len; const full=Math.floor(filled); const part=Math.max(0,Math.min(1,filled-full)); for(let j=0;j<len;j++){ const ch=word[j]||' '; let p=0; if(progress>=1) p=100; else if(progress<=0) p=0; else p=(j<full)?100:((j===full)?Math.round(part*100):0); if(KaroState.lettersOnly && ch===' ') p=0; tspan.appendChild(letterSpan(ch,p)); } } function drawTokensInto(el, words, now){ el.innerHTML=''; const grp=computeActiveGroup(words,now); const at=grp.at; const nextTime=(grp.R+1<words.length && words[grp.R+1].t!=null)? words[grp.R+1].t : (words.length? (words[words.length-1].t||at) : at); const denom=Math.max(0.001,nextTime-at); const progGlobal=Math.max(0,Math.min(1,(now-at)/denom)); for(let i=0;i<words.length;i++){ const tspan=document.createElement('span'); tspan.className='karoToken'; const w=words[i].w||''; if(i<grp.L){ pushWordLetters(tspan,w,1); } else if(i>=grp.L && i<=grp.R){ pushWordLetters(tspan,w,progGlobal); } else { pushWordLetters(tspan,w,0); } el.appendChild(tspan); } } function textTransformWords(words){ const s=words.map(w=>String(w.w||'')).join(''); const t=caseTransformText(s); let pos=0; const out=[]; for(const w of words){ const len=String(w.w||'').length; out.push({ t:w.t, w:t.slice(pos,pos+len) }); pos+=len; } return out; } function draw(nowRel){ const curr=document.getElementById('karoCurr'); const next=document.getElementById('karoNext'); if(!curr||!next) return; let li=-1; for(let i=0;i<KaroState.linesPrepared.length;i++){ const L=KaroState.linesPrepared[i]; if(L.main<=nowRel && nowRel<L.end){ li=i; break; } if(L.main>nowRel) break; } if(li<0){ curr.textContent=''; next.textContent=caseTransformText(KaroState.linesPrepared[0]?.text||''); return; } const C=KaroState.linesPrepared[li], N=KaroState.linesPrepared[li+1]||null; const tokens=(KaroState.case==='none')? (C.words||[]) : textTransformWords(C.words||[]); drawTokensInto(curr,tokens,nowRel); next.textContent=caseTransformText(N?.text||''); } function loop(){ const nowRel=(audioCtx? audioCtx.currentTime:0) - (KaroState.startAt||0); draw(nowRel); KaroState.raf=requestAnimationFrame(loop); } window.Karo={ rebuild(){ KaroState.linesPrepared=prepareLines(lyrics.json); draw(0); }, start(startAt){ KaroState.startAt=(+startAt)|| (audioCtx? audioCtx.currentTime:0); cancelAnimationFrame(KaroState.raf||0); KaroState.raf=requestAnimationFrame(loop); }, stop(){ cancelAnimationFrame(KaroState.raf||0); KaroState.raf=0; } };
  })();
  
  // ===== NEW: Whole-page fullscreen toggle =====
  (function(){
    const btn = document.getElementById('btnPageFS');
    if(!btn) return;
    const docEl = document.documentElement;

    function isFS(){ return !!document.fullscreenElement; }

    async function enterFS(){
      try { await docEl.requestFullscreen(); }
      catch(err){ const anyEl = docEl; if(anyEl && anyEl.webkitRequestFullscreen){ anyEl.webkitRequestFullscreen(); } else { try{ log('Fullscreen request failed: '+(err?.message||err)); }catch(_){} } }
    }
    async function exitFS(){
      try { await document.exitFullscreen(); }
      catch(err){ const anyDoc = document; if(anyDoc && anyDoc.webkitExitFullscreen){ anyDoc.webkitExitFullscreen(); } else { try{ log('Exit fullscreen failed: '+(err?.message||err)); }catch(_){} } }
    }
    async function toggleFS(){ if(isFS()) await exitFS(); else await enterFS(); syncUI(); }
    function syncUI(){ const active=isFS(); btn.textContent = active? '‚§¢' : '‚õ∂'; btn.setAttribute('aria-pressed', active? 'true':'false'); btn.title = active? 'Exit full screen' : 'Full screen'; }

    btn.addEventListener('click', toggleFS);
    document.addEventListener('fullscreenchange', syncUI);
    document.addEventListener('webkitfullscreenchange', syncUI);

    const viz = document.getElementById('vizWrap');
    if(viz) viz.addEventListener('dblclick', toggleFS, { passive:true });

    document.addEventListener('keydown', async (e)=>{
      if(e.shiftKey && !e.ctrlKey && !e.altKey && !e.metaKey && e.key.toLowerCase()==='f'){
        e.preventDefault();
        await toggleFS();
      }
    });

    syncUI();
  })();

  applyDensity(settings.ui.density); autoFit16();


  // === APPEND: Safe next-line sizing via ResizeObserver (no lifecycle changes) ===
  (function(){
    function updateNextSize(){
      try{
        const curr = document.getElementById('karoCurr');
        const win  = document.getElementById('winKaro');
        if(!curr || !win) return;
        const st = window.getComputedStyle(curr);
        const currPx = parseFloat(st.fontSize || '0');
        if(currPx > 0){
          const nextPx = Math.max(10, Math.round(currPx * 0.5));
          win.style.setProperty('--next-size', nextPx + 'px');
        }
      }catch(_){ /* noop */ }
    }

    function initObserver(){
      const curr = document.getElementById('karoCurr');
      if(!curr || typeof ResizeObserver === 'undefined'){ updateNextSize(); return; }
      try{
        const ro = new ResizeObserver(()=>updateNextSize());
        ro.observe(curr);
      }catch(_){ updateNextSize(); }
    }

    if(document.readyState==='loading'){
      document.addEventListener('DOMContentLoaded', initObserver, { once:true });
    } else {
      initObserver();
    }
    window.addEventListener('resize', updateNextSize, { passive:true });
  })();
  

  // === APPEND: Karaoke countdown chip (top-left of Karaoke window) ===
  (function(){
    const CHIP_ID = 'karoCountdown';
    let kRAF = 0;
    function placeChipTopLeft(){
      const win = document.getElementById('winKaro');
      if(!win) return;
      let chip = document.getElementById(CHIP_ID);
      if(!chip){
        chip = document.createElement('span');
        chip.id = CHIP_ID;
        chip.className = 'chip';
        chip.title = 'Seconds until next karaoke line starts';
        chip.textContent = '‚è± Next in: --';
        chip.style.position = 'absolute';
        chip.style.top = '0px';
        chip.style.left = '8px';
        chip.style.zIndex = '2';
      }
      // Append to Karaoke window body so absolute positioning works relative to body
      const body = win.querySelector('.winBody');
      if(body){
        try { body.style.position = body.style.position || 'relative'; }catch(_){ }
        body.appendChild(chip);
      } else {
        win.appendChild(chip);
      }
    }
    function updateCountdown(nowRel){
      const chip = document.getElementById(CHIP_ID);
      if(!chip) return;
      const lines = (function(){
        try{ return KaroState.linesPrepared || []; }catch(_){ return []; }
      })();
      if(!lines.length){ chip.textContent = '‚è± Next in: --'; chip.style.color = '#9fbad1'; chip.style.display=''; return; }
      let li = -1;
      for(let i=0;i<lines.length;i++){
        const L = lines[i];
        if(L.main <= nowRel && nowRel < L.end){ li = i; break; }
        if(L.main > nowRel) break;
      }
      const nextMain = (li >= 0 && li+1 < lines.length) ? (lines[li+1].main || NaN) : (li<0 && lines.length ? (lines[0].main || NaN) : NaN);
      const delta = (isFinite(nextMain) ? (nextMain - nowRel) : NaN);
      if(!isFinite(delta) || delta < 0){
        chip.textContent = '‚è± Next in: --';
        chip.style.color = '#9fbad1';
        return;
      }
      chip.textContent = '‚è± Next in: ' + delta.toFixed(2) + 's';
      chip.style.color = (delta < 0.20) ? '#f31260' : (delta < 0.50 ? '#f5a524' : '#9fbad1');
    }
    const origKRebuild = window.Karo && window.Karo.rebuild;
    const origKStart   = window.Karo && window.Karo.start;
    const origKStop    = window.Karo && window.Karo.stop;
    if(window.Karo){
      window.Karo.rebuild = function(){
        if(origKRebuild) origKRebuild.call(window.Karo);
        try{ placeChipTopLeft(); updateCountdown(0); }catch(_){}
      };
      window.Karo.start = function(startAt){
        if(origKStart) origKStart.call(window.Karo, startAt);
        try{ placeChipTopLeft(); }catch(_){}
        cancelAnimationFrame(kRAF||0);
        const loop = ()=>{
          const nowRel=(audioCtx? audioCtx.currentTime:0) - (KaroState.startAt||0);
          try{ updateCountdown(nowRel); }catch(_){}
          kRAF = requestAnimationFrame(loop);
        };
        kRAF = requestAnimationFrame(loop);
      };
      window.Karo.stop = function(){
        cancelAnimationFrame(kRAF||0); kRAF = 0;
        if(origKStop) origKStop.call(window.Karo);
      };
    }
  })();

  // === APPEND: Karaoke BIG start countdown (dynamic to first highlight, once per song) ===
  (function(){
    const ROW_ID   = 'karoStartRowDynamic';
    const BIG_ID   = 'karoStartBigDynamic';
    const BARS_ID  = 'karoStartBarsDynamic';
    const SEG_CLASS= 'karoStartSegDynamic';
    const SEGMENTS = 6;

    let raf = 0;
    let didShow = false;
    let endTime = 0;
    let startStamp = 0;

    function buildRow(){
      if(document.getElementById(ROW_ID)) return;
      const body = document.querySelector('#winKaro .winBody');
      const curr = document.getElementById('karoCurr');
      if(!body) return;
      const row = document.createElement('div');
      row.id = ROW_ID;
      row.style.display = 'block';
      row.style.textAlign = 'center';
      row.style.margin = '4px 0 8px';
      row.style.position = 'relative';

      const big = document.createElement('div');
      big.id = BIG_ID;
      big.style.fontWeight = '800';
      big.style.fontSize = 'clamp(24px, 6.8vw, 72px)';
      big.style.lineHeight = '1.0';
      big.style.color = 'var(--accent)';
      big.style.textShadow = '0 0 14px rgba(0,179,255,0.65), 0 0 28px rgba(0,179,255,0.35)';
      big.textContent = '';

      const bars = document.createElement('div');
      bars.id = BARS_ID;
      bars.style.display = 'flex';
      bars.style.gap = '6px';
      bars.style.justifyContent = 'center';
      bars.style.alignItems = 'flex-end';
      bars.style.height = '28px';
      bars.style.marginTop = '6px';

      for(let i=0;i<SEGMENTS;i++){
        const seg = document.createElement('div');
        seg.className = SEG_CLASS;
        const h = 10 + Math.round((i+1) * (18/SEGMENTS));
        seg.style.width = '8px';
        seg.style.height = h + 'px';
        seg.style.borderRadius = '3px';
        seg.style.background = 'var(--accent)';
        seg.style.boxShadow = '0 0 8px rgba(0,179,255,0.5)';
        seg.style.opacity = '1.0';
        bars.appendChild(seg);
      }

      const brand = document.createElement('div');
      brand.className = 'karoStartBrand';
      brand.textContent = 'KaraokeHD¬©';
      brand.style.marginTop = '4px';
      brand.style.fontSize = '15px';
      brand.style.color = '#000000FF';
      brand.style.letterSpacing = '0.02em';
      brand.style.opacity = '0.85';

      row.appendChild(big);
      row.appendChild(bars);
      row.appendChild(brand);
      if(curr && curr.parentNode){ curr.parentNode.insertBefore(row, curr); }
      else { body.insertBefore(row, body.firstChild); }
    }

    function removeRow(){
      cancelAnimationFrame(raf||0); raf = 0;
      const row = document.getElementById(ROW_ID);
      if(row) row.remove();
    }

    function updateBars(delta){
      const list = document.querySelectorAll('#'+BARS_ID+' .'+SEG_CLASS);
      if(!list || !list.length) return;
      const span = Math.max(0.001, endTime - startStamp);
      const pct  = Math.max(0, Math.min(1, delta / span));
      const left = Math.ceil(pct * SEGMENTS);
      for(let i=0;i<list.length;i++){
        list[i].style.opacity = (i < left) ? '1.0' : '0.25';
      }
    }

    function loop(){
      const now = (audioCtx ? audioCtx.currentTime : 0);
      const delta = endTime - now;
      if(delta <= 0){ removeRow(); return; }
      const big = document.getElementById(BIG_ID);
      if(big) big.textContent = Math.max(0, Math.ceil(delta)).toString();
      updateBars(delta);
      raf = requestAnimationFrame(loop);
    }

    function isWordHighlightable(w){
      if(!w) return false;
      const s = String(w.w || '').trim();
      if(!s) return false;
      if(s === '\u2420' || s === '‚ê†') return false;
      if(/^<---karaokeHD--->$/.test(s)) return false;
      return true;
    }
    function getFirstHighlightSec(){
      try{
        const lines = (KaroState && Array.isArray(KaroState.linesPrepared)) ? KaroState.linesPrepared : [];
        for(let i=0;i<lines.length;i++){
          const L = lines[i] || {};
          if(/^<---karaokeHD--->$/.test(String(L.text||''))) continue;
          const words = Array.isArray(L.words) ? L.words : [];
          for(let j=0;j<words.length;j++){
            const w = words[j];
            const t = (w && typeof w.t === 'number') ? w.t : NaN;
            if(isFinite(t) && t > 0.001 && isWordHighlightable(w)) return t;
          }
        }
      }catch(_){ }
      return NaN;
    }

    const origRebuild = window.Karo && window.Karo.rebuild;
    const origStart   = window.Karo && window.Karo.start;
    const origStop    = window.Karo && window.Karo.stop;
    if(window.Karo){
      window.Karo.rebuild = function(){
        didShow = false;
        removeRow();
        if(origRebuild) origRebuild.call(window.Karo);
      };
      window.Karo.start = function(startAt){
        if(origStart) origStart.call(window.Karo, startAt);
        try{
          if(!didShow){
            const base = (typeof lyrics.startAt === 'number') ? lyrics.startAt : (audioCtx ? audioCtx.currentTime : 0);
            const hSec = getFirstHighlightSec();
            if(!isFinite(hSec) || hSec <= 0.05){
              didShow = true;
              return;
            }
            buildRow();
            startStamp = (audioCtx ? audioCtx.currentTime : 0);
            endTime = base + hSec;
            cancelAnimationFrame(raf||0);
            raf = requestAnimationFrame(loop);
            didShow = true;
          }
        }catch(_){ }
      };
      window.Karo.stop = function(){
        removeRow();
        if(origStop) origStop.call(window.Karo);
      };
    }
  })();
  
  // === APPEND: Non-invasive Karaoke countdown overlay (chip + live updater) ===
  (function(){
    const CHIP_ID = 'karoCountdown';
    let kRAF = 0;

    function ensureKaroCountdownChip(){
      if(document.getElementById(CHIP_ID)) return;
      const win = document.getElementById('winKaro');
      if(!win) return;
      const body = win.querySelector('.winBody');
      if(!body) return;
      const chip = document.createElement('span');
      chip.id = CHIP_ID;
      chip.className = 'chip';
      chip.title = 'Seconds until next karaoke line starts';
      chip.style.position = 'absolute';
      chip.style.right = '8px';
      chip.style.top = '8px';
      chip.style.zIndex = '2';
      chip.style.backdropFilter = 'blur(2px)';
      chip.textContent = '‚è± Next in: --';
      try { body.style.position = body.style.position || 'relative'; }catch(_){ }
      body.appendChild(chip);
    }

    function updateKaroCountdown(nowRel){
      const chip = document.getElementById(CHIP_ID);
      if(!chip) return;
      const lines = (function(){
        try{ return KaroState.linesPrepared || []; }catch(_){ return []; }
      })();
      if(!lines.length){ chip.textContent = '‚è± Next in: --'; chip.style.color = '#9fbad1'; chip.style.display=''; return; }
      let li = -1;
      for(let i=0;i<lines.length;i++){
        const L = lines[i];
        if(L.main <= nowRel && nowRel < L.end){ li = i; break; }
        if(L.main > nowRel) break;
      }
      const nextMain = (li >= 0 && li+1 < lines.length) ? (lines[li+1].main || NaN) : (li<0 && lines.length ? (lines[0].main || NaN) : NaN);
      const delta = (isFinite(nextMain) ? (nextMain - nowRel) : NaN);
      if(!isFinite(delta) || delta < 0){
        chip.textContent = '‚è± Next in: --';
        chip.style.color = '#9fbad1';
        return;
      }
      chip.textContent = '‚è± Next in: ' + delta.toFixed(2) + 's';
      chip.style.color = (delta < 0.20) ? '#f31260' : (delta < 0.50 ? '#f5a524' : '#9fbad1');
    }

    const origKRebuild = window.Karo && window.Karo.rebuild;
    const origKStart   = window.Karo && window.Karo.start;
    const origKStop    = window.Karo && window.Karo.stop;
    if(window.Karo){
      window.Karo.rebuild = function(){
        if(origKRebuild) origKRebuild.call(window.Karo);
        try{ ensureKaroCountdownChip(); updateKaroCountdown(0); }catch(_){}
      };
      window.Karo.start = function(startAt){
        if(origKStart) origKStart.call(window.Karo, startAt);
        try{ ensureKaroCountdownChip(); }catch(_){}
        cancelAnimationFrame(kRAF||0);
        const loop = ()=>{
          const nowRel=(audioCtx? audioCtx.currentTime:0) - (KaroState.startAt||0);
          try{ updateKaroCountdown(nowRel); }catch(_){}
          kRAF = requestAnimationFrame(loop);
        };
        kRAF = requestAnimationFrame(loop);
      };
      window.Karo.stop = function(){
        cancelAnimationFrame(kRAF||0); kRAF = 0;
        if(origKStop) origKStop.call(window.Karo);
      };
    }
  })(); 

(function(){
  function centerKaroWindow(){
    const w = document.getElementById('winKaro');
    if(!w) return;
    // Make sure it's visible so we can measure size accurately
    const prevDisplay = w.style.display;
    w.style.display = 'block';
    w.style.zIndex  = (++zCounter).toString();

    // Measure after layout paints
    requestAnimationFrame(() => {
      try{
        const vw = window.innerWidth;
        const vh = window.innerHeight;
        const rect = w.getBoundingClientRect();
        const width  = rect.width  || w.offsetWidth || 680; // fallback
        const height = rect.height || w.offsetHeight || 320; // fallback

        // Center, with a small safe padding from edges
        const PAD = 8;
        const left = Math.max(PAD, Math.round((vw - width)  / 2));
        const top  = Math.max(PAD, Math.round((vh - height) / 2));

        w.style.left = left + 'px';
        w.style.top  = top  + 'px';

        // Persist to localStorage
        settings.windows = settings.windows || {};
        settings.windows['winKaro'] = settings.windows['winKaro'] || {};
        settings.windows['winKaro'].left  = w.style.left;
        settings.windows['winKaro'].top   = w.style.top;
        settings.windows['winKaro'].width = w.style.width;   // keep whatever the user had
        settings.windows['winKaro'].display = 'block';       // ensure visible
        persistSettings();

        try{ log('Karaoke window centered'); }catch(_){}
      }catch(e){
        try{ log('Center failed: ' + (e.message || e)); }catch(_){}
      }
    });

    // Keep it shown (we want the user to see it).
    // If you prefer restoring the previous display state when it was 'none',
    // uncomment the next line:
    // if(prevDisplay==='none') w.style.display = 'block';
  }

  const btn = document.getElementById('karoResetPos');
  if(btn) btn.addEventListener('click', centerKaroWindow);
})();

 </script>





<script>
(() => {
  const $ = (sel) => document.querySelector(sel);

  // ---------- Apply to karoCurr/karoNext ----------
  function applyKaraokeFont(familyName) {
    document.documentElement.style.setProperty('--karaokeFont', `"${familyName}"`);
    ['karoCurr', 'karoNext'].forEach(id => {
      const el = document.getElementById(id);
      if (el) el.style.fontFamily = `"${familyName}"`;
    });
    localStorage.setItem('karaoke.font.family', familyName);
    // Preload to reduce FOIT/FOUT
    document.fonts.load(`16px "${familyName}"`).catch(()=>{});
  }

  // Restore on load
  const saved = localStorage.getItem('karaoke.font.family');
  if (saved) applyKaraokeFont(saved);

  // ---------- Upload (no server): FontFace + blob URL ----------
  async function useUploadedFont(file) {
    if (!file) { alert('Select a font file first.'); return; }
    const family = file.name.replace(/\.(ttf|otf|woff2?|)$/i, '');
    const blobUrl = URL.createObjectURL(file);
    const ff = new FontFace(family, `url(${blobUrl})`);
    await ff.load();                   // CSS Font Loading API
    document.fonts.add(ff);            // CSS Font Loading API

    // Update picker
    const picker = $('#ks-font-family');
    if (picker) {
      const opt = document.createElement('option');
      opt.value = family;
      opt.textContent = `${family} (uploaded)`;
      picker.insertBefore(opt, picker.firstChild);
      picker.value = family;
    }
    applyKaraokeFont(family);
    // Keep blob URL alive for this session
    sessionStorage.setItem('karaoke.font.upload.sessionUrl', blobUrl);
  }

  // ---------- Optional persistence with IndexedDB ----------
  const IDB_NAME = 'karaoke-fonts';
  const IDB_STORE = 'fonts';
  let db;
  function openDB() {
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(IDB_NAME, 1);
      req.onupgradeneeded = (e) => {
        const d = e.target.result;
        if (!d.objectStoreNames.contains(IDB_STORE)) {
          d.createObjectStore(IDB_STORE, { keyPath: 'family' });
        }
      };
      req.onsuccess = (e) => { db = e.target.result; resolve(db); };
      req.onerror = (e) => reject(e.target.error);
    });
  }

  async function saveFontToIDB(file) {
    if (!file) { alert('Select a font file first.'); return; }
    const family = file.name.replace(/\.(ttf|otf|woff2?|)$/i, '');
    await openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(IDB_STORE, 'readwrite');
      const store = tx.objectStore(IDB_STORE);
      const putReq = store.put({ family, blob: file, label: `${family} (local)` });
      tx.oncomplete = () => resolve(family);
      tx.onerror = (e) => reject(e.target.error);
    });
  }

  async function loadFontsFromIDB() {
    await openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(IDB_STORE, 'readonly');
      const store = tx.objectStore(IDB_STORE);
      const req = store.getAll();
      req.onsuccess = async (e) => {
        const fonts = e.target.result || [];
        for (const f of fonts) {
          // Create a blob URL and register
          const url = URL.createObjectURL(f.blob);
          const ff = new FontFace(f.family, `url(${url})`);
          try {
            await ff.load();
            document.fonts.add(ff);
            // Add to picker
            const picker = $('#ks-font-family');
            if (picker) {
              const opt = document.createElement('option');
              opt.value = f.family;
              opt.textContent = f.label || `${f.family} (local)`;
              picker.appendChild(opt);
            }
          } catch (err) {
            console.warn('Failed to load IDB font:', f.family, err);
          }
        }
        resolve(fonts.length);
      };
      req.onerror = (e) => reject(e.target.error);
    });
  }

  // Load any persisted fonts on startup
  loadFontsFromIDB().then((count) => {
    const status = $('#ks-device-fonts-status');
    if (status && count) status.textContent = `Loaded ${count} saved fonts (local).`;
  }).catch(()=>{});

  // ---------- Device font listing (if supported) ----------
  async function scanDeviceFonts() {
    const status = $('#ks-device-fonts-status');
    // Requires secure context (HTTPS or localhost) + user permission; not on file://
    if (!('queryLocalFonts' in window)) {
      status.textContent = 'Device font listing not supported in this context.';
      return;
    }
    try {
      const fonts = await window.queryLocalFonts();  // Permission prompt on first call
      const picker = $('#ks-font-family');
      const seen = new Set();
      let added = 0;
      fonts.forEach(f => {
        const family = f.fullName || f.family || f.postscriptName || 'Unknown';
        if (seen.has(family)) return;
        seen.add(family); added++;
        const opt = document.createElement('option');
        opt.value = family; opt.textContent = `${family} (device)`;
        picker.appendChild(opt);
      });
      status.textContent = `Found ${added} device fonts.`;
    } catch (err) {
      status.textContent = `Denied or unavailable (${err.name}).`;
    }
  }

  // ---------- Manual device font test (fallback) ----------
  // Tries to detect if a typed font name is present by comparing canvas text metrics.
  function isFontAvailable(fontName) {
    const testText = 'mmmmmmmmmmWWWWWWWWW12345';
    const size = 64;
    const canvas = document.createElement('canvas');
    canvas.width = 1000; canvas.height = 200;
    const ctx = canvas.getContext('2d');
    // Measure with a generic fallback
    ctx.font = `${size}px sans-serif`;
    const baseline = ctx.measureText(testText).width;
    // Measure with requested font (if not present, width is usually identical)
    ctx.font = `${size}px "${fontName}", sans-serif`;
    const withFont = ctx.measureText(testText).width;
    return Math.abs(withFont - baseline) > 0.5; // heuristic threshold
  }

  function testAndApplyManualFont() {
    const name = $('#ks-font-manual-name').value.trim();
    if (!name) return;
    const status = $('#ks-device-fonts-status');
    if (isFontAvailable(name)) {
      // Try to apply directly; optional: also define @font-face local() rule
      applyKaraokeFont(name);
      status.textContent = `Applied device font: ${name}`;
    } else {
      status.textContent = `Font not detected: ${name}. Try uploading the TTF.`;
    }
  }

  // ---------- Wire up ----------
  const picker = $('#ks-font-family');
  if (picker) picker.addEventListener('change', (e) => applyKaraokeFont(e.target.value));

  const uploadBtn = $('#ks-font-use-upload');
  const idbBtn = $('#ks-font-save-idb');
  const fileInput = $('#ks-font-file');
  const scanBtn = $('#ks-scan-device-fonts');
  const testBtn = $('#ks-test-manual-font');

  if (uploadBtn) uploadBtn.addEventListener('click', () => useUploadedFont(fileInput.files?.[0]));
  if (idbBtn) idbBtn.addEventListener('click', async () => {
    try {
      const fam = await saveFontToIDB(fileInput.files?.[0]);
      // Immediately load from IDB so the font becomes active
      await loadFontsFromIDB();
      applyKaraokeFont(fam);
      const picker = $('#ks-font-family');
      if (picker) picker.value = fam;
    } catch (e) { alert('Save failed: ' + e.message); }
  });
  if (scanBtn) scanBtn.addEventListener('click', () => scanDeviceFonts());
  if (testBtn) testBtn.addEventListener('click', () => testAndApplyManualFont());
})();
</script>

<script>
(() => {
  const $ = (sel) => document.querySelector(sel);

  // ---- Where to apply the chosen font (your karaoke lines)
  function applyKaraokeFont(familyOrStack) {
    // Use CSS var so your CSS rule `#karoCurr, #karoNext { font-family: var(--karaokeFont); }` picks it up.
    document.documentElement.style.setProperty('--karaokeFont', familyOrStack);

    // Inline override (wins if other rules compete)
    ['karoCurr', 'karoNext'].forEach(id => {
      const el = document.getElementById(id);
      if (el) el.style.fontFamily = familyOrStack;
    });

    localStorage.setItem('karaoke.font.choice', familyOrStack);
    // Preload to reduce FOIT/FOUT
    // Try to load the first quoted name (or the first unquoted token) for better preloading.
    const first = (familyOrStack.match(/"([^"]+)"/) || familyOrStack.split(',')[0] || '').toString().replace(/(^"|"$)/g,'');
    if (first) document.fonts.load(`16px ${first}`).catch(()=>{});
  }

  // ---- Your preset font lists
  const PRESETS = {
    'Windows': [
      'Segoe UI Variable Text',   // Win11 variable UI (Text)  // Source: Edge team guidance
      'Segoe UI Variable Display',// Win11 variable UI (Display)
      'Segoe UI Variable Small',  // Win11 variable UI (Small)
      'Segoe UI',                 // Win10/Win11 classic UI
      'Bahnschrift'               // Variable (wght, wdth)
    ],
    'Android': [
      'Roboto',
      'Noto Sans',
      'Droid Sans',
      'Roboto Flex'               // May not exist on all devices
    ],
    'Linux': [
      'Ubuntu',
      'Cantarell',
      'Noto Sans',
      'DejaVu Sans',
      'FreeSans'
    ],
    'Cross-platform': [
      'system-ui stack'           // Composite native stack
    ]
  };

  // Composite stack string (cross‚ÄëOS ‚Äúnative‚Äù look)
  const FAMILY_MAP = {
    'system-ui stack': 'system-ui, "Segoe UI", Roboto, "Noto Sans", "Helvetica Neue", Arial, sans-serif'
  };

  // ---- Populate #ks-font-family with optgroups
  function addPresetOptions() {
    const picker = $('#ks-font-family');
    if (!picker) return;

    // Keep existing options (from uploads or device scan), then append our groups
    Object.entries(PRESETS).forEach(([groupLabel, fonts]) => {
      const og = document.createElement('optgroup');
      og.label = groupLabel;
      fonts.forEach(name => {
        const opt = document.createElement('option');
        opt.value = (name in FAMILY_MAP) ? FAMILY_MAP[name] : `"${name}"`; // quote real names; stacks are full lists
        opt.textContent = name;
        og.appendChild(opt);
      });
      picker.appendChild(og);
    });

    // Restore last chosen font (if any)
    const saved = localStorage.getItem('karaoke.font.choice');
    if (saved) {
      // If saved value matches one of the new option values, select it.
      const match = Array.from(picker.options).find(o => o.value === saved);
      if (match) picker.value = saved, applyKaraokeFont(saved);
    }
  }

  // ---- Wire change handler
  function wirePicker() {
    const picker = $('#ks-font-family');
    if (!picker) return;
    picker.addEventListener('change', (e) => {
      const val = e.target.value;
      applyKaraokeFont(val);
    });
  }

  // ---- Boot
  addPresetOptions();
  wirePicker();

  // Optional: if you have a ‚ÄúFont source‚Äù select (#ks-font-source), refresh list when changing.
  const src = $('#ks-font-source');
  if (src) src.addEventListener('change', () => {
    // Do nothing special; presets remain in the list alongside uploads/device fonts.
    // If you prefer to hide presets for certain sources, filter here.
  });
})();
</script>


</body>
</html>
